;  Copyright 2007, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id: farm_connect_taskdl.pro,v 1.5 2007/11/27 21:38:50 qchau Exp $
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CVS

FUNCTION farm_connect_taskdl, $
    i_num_workers,       $
    i_optional_arg

; Program provides a way for other IDL program/procedure to connect to the TaskDL library.
; TaskDL is a library of IDL functions to spawn IDL workers on the slave nodes from the main
; node to take advantage of idling CPU resources.
 
; Assumption: 
; 
; 1. The program is run from a main node.
; 2. The list of slave nodes are in environment variable GHRSST_CLUSTER_HOST_FILENAME_LIST.

; These common variables allow other related functions to use the shared TaskDL objects.
; 

COMMON SHARE_MEMORY, s_farm_handle;    Static s_farm_handle is shared between IDL subroutines.

;
; Load cluster management constants.
;

@cluster_management.cfg

; Local variables and start program.

tstart = systime(1)
print, 'farm_connect_taskdl: execution start time:', systime() 

over_all_status = SUCCESS;
max_num_workers = 0;

print, 'farm_connect_taskdl: i_num_workers = ', i_num_workers 

;
; Allocate enough room for the host names.
;

host_names = strarr(NUM_SLAVE_NODES)

;
; Get the list of hosts to create workers on.
;

host_filename = GETENV('GHRSST_CLUSTER_HOST_FILENAME_LIST');
openr, file_unit, ERROR = error_number, host_filename, /get_lun

if (error_number NE 0) then begin
    print, 'farm_connect_taskdl: ERROR, Cannot open file for input:[', host_filename,']'; 
    over_all_status = FAILURE;
    exit;
end

;
; Read in as many host names as in the host file. 
;

worker_index = 0;

tmpstr = '';  Must set this to null string to signify that it is a variable string.

while (~eof(file_unit) AND worker_index LT NUM_SLAVE_NODES) do begin

    ; Get the host name from file first.
    readf, file_unit, tmpstr

    ; Skip lines with ';' in front or blank line.

    trimmed_line = STRTRIM(tmpstr,2);
    line_length = STRLEN(trimmed_line);

    if ((line_length EQ 0) OR STRMID(trimmed_line,0,1) EQ ';') then begin
;print, 'farm_connect_taskdl: Ignore this line: ' + STRING('[',trimmed_line,']');
    endif else begin
        ; Save the name. 
        host_names[worker_index] = trimmed_line;

print, 'farm_connect_taskdl: saving = [', host_names[worker_index], '] index ', worker_index

        ; Keep track of how many read so far.
        worker_index += 1;
    endelse

endwhile

; Give logical file unit back to the system.

free_lun, file_unit

;
; Save the number of workers read.
;

max_num_workers = worker_index;

;
; Reset to the number of workers in the input if more are read in from the host list. 
;

if (max_num_workers GT i_num_workers) then begin
    max_num_workers = i_num_workers;
    print, "farm_connect_taskdl: resetting max_num_workers to ", max_num_workers
endif
help, max_num_workers;

;
; Get the number of runtime licenses available.
;

l_actual_runtime_licenses_available = get_runtime_licenses_available();

; Only lock the license if there is at least one available.

if (l_actual_runtime_licenses_available GT 0) then begin
    l_lock_status = lock_idl_license_manager();

print, 'farm_connect_taskdl: l_lock_status = ', l_lock_status, ', 1 means good, 0 means bad';
    if (l_lock_status EQ 0) then begin
        print, 'farm_connect_taskdl: ERROR, Failed in lock_idl_license_manager().';
        print, 'farm_connect_taskdl: Must return without doing any work.'
        over_all_status = FAILURE;
        return, over_all_status; 
    end
endif

;
; Return immediately if there are no more run time licenses available.
;

if (l_actual_runtime_licenses_available LE 0) then begin
    print, 'farm_connect_taskdl: ERROR, There are no run time licenses available.'
    print, 'farm_connect_taskdl: l_actual_runtime_licenses_available = ', l_actual_runtime_licenses_available
    print, 'farm_connect_taskdl: Must return without doing any work.'
    over_all_status = FAILURE; 
    return, over_all_status
end

;
; Use the smaller of the two: max_num_workers, l_actual_runtime_licenses_available
; Basically, create as many workers as licenses available.
;

help, l_actual_runtime_licenses_available
help,  max_num_workers

if (l_actual_runtime_licenses_available LE max_num_workers) then begin
     max_num_workers = l_actual_runtime_licenses_available;
     print, "farm_connect_taskdl: resetting max_num_workers to ", max_num_workers
endif
help, max_num_workers 

;
; Create a farm.
;

print, "farm_connect_taskdl: pre OBJ_NEW taskdl"
l2pFarm = OBJ_NEW('taskdl');
print, "farm_connect_taskdl: post OBJ_NEW taskdl"

;
; Since binding errors do occur if the same port is used between runs, we 
; will generate random numbers. 
;

server_port = LONG(10000 * RANDOMU(SYSTIME(/SECONDS)) + 20000);
print, 'farm_connect_taskdl: server_port = ', server_port

;
; Get the user's home to specify where to place the tdl.log and worker's logs.
;

my_default_home = GETENV('HOME');
;my_default_home  = ""; 
my_taskdl_output = ""; 

my_taskdl_output = my_default_home + '/task_farm_output';
l_do_not_care_status = actualize_directory(my_taskdl_output);

; Add the additional directory if i_optional_arg is not null

if (N_ELEMENTS(i_optional_arg)) then begin
    my_taskdl_output = my_taskdl_output + '/' + i_optional_arg;
    l_do_not_care_status = actualize_directory(my_taskdl_output);
endif

;
;
; Each farm need a session.  The tdl server is run on our behalf.
; After open_session, the following are true:
;
;   1.  The session directory is created and log files will be placed there.
;   2.  The default queue is created.
;

; Create a catch block to catch error(s)

CATCH, error_status
if (error_status NE 0) then begin
    CATCH, /CANCEL
    print, 'farm_connect_taskdl: ERROR, Failed in open_session.'
    print, 'server_port = ',server_port

    l_status = error_log_writer($
        'farm_connect_taskdl',$
        'Failed in open_session:');

    over_all_status = FAILURE;

    ; Remove the IDL object.
    obj_destroy, l2pFarm
    CATCH, /CANCEL

    ; Don't forget to release the IDL license
    release_idl_license_manager

    ; Must return immediately.
    return, over_all_status
endif

l2pFarm->open_session, PORT = server_port, SESSION_DIR = my_taskdl_output 
CATCH, /CANCEL

; Check to make sure the session got started OK.  If not, we return immediately.
;
; Sometimes, due to network problem or the server_port is used by another process,
; the session will fail to start.  The catch block above does not catch if the
; session fail to start.  We have to go the operating system to look for an "sh" process
; containing the server_port in the 'ps -ef' output line.
;

session_start_status = verify_taskdl_session_started(server_port);

;help, session_start_status
;print, "session_start_status = ", session_start_status
;print, "SUCCESS = ",SUCCESS

if (session_start_status NE SUCCESS) then begin
    print, "farm_connect_taskdl: ERROR, TaskDL failed to start with server_port:" + STRING(server_port);
    print, 'server_port = ',server_port

    l_status = error_log_writer($
        'farm_connect_taskdl',$
        'Failed in open_session with server_port:' + STRING(server_port));
    ; Remove the IDL object.
    obj_destroy, l2pFarm
    CATCH, /CANCEL

    over_all_status = FAILURE;

    ; Don't forget to release the IDL license
    release_idl_license_manager

    ; Must return immediately.
    return, over_all_status
endif

;
; Save the TaskDL object to static variable.
;

s_farm_handle = l2pFarm;

;
; Create enough farms to farm the land.
;

for host_num = 0, max_num_workers - 1 do begin

  ; Create a catch block to catch error(s)
  ; Note: spawn_worker does not throw an exception if host cannot be found.
  ;       It does however throw an exception if the keyword(s) are misspelled.

  CATCH, error_status
  if (error_status NE 0) then begin
      CATCH, /CANCEL
      print, 'farm_connect_taskdl: ERROR, Failed in spawn_worker.'
      print, 'host_num = ', host_num
      print, 'host_names = ',  host_names[host_num]

      l_status = error_log_writer($
          'farm_connect_taskdl',$
          'Failed in spawn_worker: host_name = ' + host_names[host_num]);

      over_all_status = FAILURE;

      ; From reference manual:
      ;
      ; "Remove all tasks from all queues on the TaskDL server.  
      ; This creates a "clean slate" to start an entirely new workflow or to recover from errors.
      ;

      l2pFarm->reset_server
      print, 'farm_connect_taskdl: obj_destroy() called' 
      obj_destroy, l2pFarm
      CATCH, /CANCEL


      ; Don't forget to release the IDL license
      release_idl_license_manager

      ; Must return immediately.
      return, over_all_status
  endif

print, 'farm_connect_taskdl: spawn_worker, host_num = ',host_num
print, 'farm_connect_taskdl: spawn_worker, host_name = ', host_names[host_num]

  ;
  ; Each farm will need a farmer.
  ;

  ; Only spawn the worker if the slave node is up.

  if (check_for_slave_node_up(host_names[host_num]) EQ 1) then begin
print, 'farm_connect_taskdl: host_name = ', host_names[host_num], ' is up';
      l2pFarm->spawn_worker, HOST = host_names[host_num]
      CATCH, /CANCEL
  endif else begin
print, 'farm_connect_taskdl: host_name = ', host_names[host_num], ' is down';
  endelse

  ;
  ; Note on above program spawn_worker:
  ;
  ; If the host is not found, the TaskDL will start two processes.  They will have to be manually
  ; killed.
  ;
  ; ps -ef | grep taskdl
  ;
  ; 902 31734     1  0 16:36 pts/4 00:00:00 sh -c /usr/depot/cots/redhat/taskdl/2.0.0/bin/tdl 20356 > ./taskdl_session/tdl.log 2>&1
  ; 902 31735 31734  0 16:36 pts/4 00:00:00 /usr/depot/cots/redhat/taskdl/2.0.0/bin/tdl 20356

  ;
  ; kill -9 31734 31735 
  ;
  ; Without a proper worker, any subsequent tasks will not be executed.
  ;
  ; Recommendation:
  ;
  ; The host_names array should have a valid node name.
  ;
  ; If the host was found, taskDL will start 3 processes:
  ;
  ; ps -ef | grep taskdl
  ;
  ; 902  1406 1     0 16:42 pts/4    00:00:00 sh -c /usr/depot/cots/redhat/taskdl/2.0.0/bin/tdl 21372 > ./taskdl_session/tdl.log 2>&1
  ; 902  1407 1406  0 16:42 pts/4    00:00:00 /usr/depot/cots/redhat/taskdl/2.0.0/bin/tdl 21372
  ; 902  1506 1     0 16:42 pts/4    00:00:00 ssh seaworld2 ${TASKDL2_DIR}/bin/taskdlstart seaworld.jpl.nasa.gov 21372 ./taskdl_session /home/ghrsst_ps/taskdl/examples 1 "idl -rt=${TASKDL2_DIR}/idl/taskdl.sav"
  ;
  ; When the tasks are done, these processes will be killed below:
  ;
  ;    l2pFarm->close_session


  ;
  ; Give it some time in-between spawn_worker() function.
  ;
  print, 'Waiting 3 seconds...'
  WAIT, 3

  ; Check to make sure the worker started OK.  If not, we return immediately.
  ;
  ; Sometimes, due to network problem or the server_port is used by another process,
  ; the worker will fail to start.  The catch block above does not catch if the
  ; worker fail to start.  We have to go the operating system to look for an "ssh" process
  ; containing the server_port in the 'ps -ef' output line.
  ;

  worker_start_status = verify_taskdl_worker_started(server_port,host_names[host_num]);

  if (worker_start_status NE SUCCESS) then begin
      print, "farm_connect_taskdl: ERROR, IDL worker failed to start with server_port:" + STRING(server_port) $
                                                                                     + " " + host_names[host_num];
      print, 'server_port = ',server_port
      print, 'host_name   = ',host_names[host_num]
  
;      l2pFarm->spawn_worker, HOST = host_names[host_num]
      l_status = error_log_writer($
          'farm_connect_taskdl',$
          'Failed in spawn_worker with server_port:' + STRING(server_port) + " " + host_names[host_num]);
      ; Remove the IDL object.
      obj_destroy, l2pFarm
      CATCH, /CANCEL
  
      over_all_status = FAILURE;

      ; Don't forget to release the IDL license
      release_idl_license_manager

      ; Must return immediately.
      return, over_all_status
  endif

endfor

;
; Release the IDL licenses manager.
;

release_idl_license_manager

return, over_all_status

END
