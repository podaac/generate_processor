;  Copyright 2010, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id$
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CVS

;------------------------------------------------------------------------------------------------------------------------
FUNCTION debug_print, i_debug_flag, i_function_name, i_level, i_print_string
  if (i_debug_flag EQ 1) then begin
      print, i_function_name, ':', i_level, ':', i_print_string;
  endif
  RETURN, 1;
END

;------------------------------------------------------------------------------------------------------------------------
FUNCTION _logger_print, i_debug_flag, i_function_name, i_level, i_print_string
  ; Send a string to log file if user has i_debug_flag set to 1.
  COMMON SHARE_MEMORY, s_log_handle
  if (i_debug_flag EQ 1) then begin
      now_is = SYSTIME(/UTC);
      printf, s_log_handle, now_is + ':' + i_function_name + ':' + i_level + ':' + i_print_string;
      FLUSH, s_log_handle; We wish to see the content of the file so we flush after each IO.
  endif
  RETURN, 1;
END

;------------------------------------------------------------------------------------------------------------------------
FUNCTION create_clusterjob_directory, $
             i_unique_clusterjob_directory

; Function create a directory if it does not already exist.
; In any case, the original directory name is returned.

if (i_unique_clusterjob_directory EQ "") then begin
    print, 'create_clusterjob_directory:ERROR, input variable i_unique_clusterjob_directory is empty string. Nothing to do.';
endif else begin
    if (FILE_TEST(i_unique_clusterjob_directory,/DIRECTORY) EQ 0) then begin
        FILE_MKDIR, i_unique_clusterjob_directory;
    endif
endelse
return, i_unique_clusterjob_directory;
END
;------------------------------------------------------------------------------------------------------------------------

PRO idl_monitor_jobs_completion, $
    i_filelist_name, $
    i_sentinel_job_name, $
    i_unique_clusterjob_directory

; Program receives a filename containig a list of empty files (signifying that a particular partial job is completed) to look for.
; If all the files exist, we consider them done.
;
; Once all jobs are completed, it will execute the given task, i.e. 'signal_complete,"/home/qchau/ancillary_processing/data/__clusterjob.1266343896'
;
; Assumptions:
;
; 1.  The strings representing the IDL program call contains the correct format. 
; 2.  No other error checking is done on the string in.  It is assume that the string contains valid program call and
;     the correct number of parameters.
;

; We share the variable s_log_handle between functions in this file so we don't have to pass it aroundd.

COMMON SHARE_MEMORY, s_log_handle

BOGUS_LOG_HANDLE = 999999;
s_log_handle = BOGUS_LOG_HANDLE;
big_log_filename = "DUMMY";

FUNCT_NAME = 'idl_monitor_jobs_completion';

    args = COMMAND_LINE_ARGS(COUNT = argCount);

;print, 'argcount ', argCount;
    IF argCount EQ 0 THEN BEGIN
        PRINT, 'idl_monitor_jobs_completion:No input arguments specified'
        RETURN
    ENDIF ELSE BEGIN
;print, 'args ', size(args);
;help,    args[0];
        i_filelist_name = args[0]
        i_sentinel_job_name = args[1];
        i_unique_clusterjob_directory = args[2];
    ENDELSE

DEBUG_FLAG = 0; Set to 1 if wish to turn on debug printing.  This flag can be set at run time with environment variable GAPMULTIPROCESSESDEBUGFLAG set to true/TRUE.
; We also allow this flag to be set from the operating system as well.

if ((STRUPCASE(GETENV('GAPFARMMULTIPROCESSESDEBUGFLAG'))) EQ 'TRUE') then begin
    DEBUG_FLAG = 1; Set to 1 if wish to turn on debug printing.
    ret_unique_clusterjob_directory = GETENV('HOME') + "/task_farm_output"; 

    ; Create a unique log file name so simultaneous programs don't have to worry about clobbering each other's log file.
    ; Get the position of the substring '__clusterjob' and copy it until the end. 

    pos_of_clusterjob_string = STRPOS(i_unique_clusterjob_directory,"__clusterjob");
    last_sub_unique_directoryname = ""; 

    if (STRPOS(i_unique_clusterjob_directory,"/",/REVERSE_SEARCH) EQ (STRLEN(i_unique_clusterjob_directory) - 1)) then begin
        ; The directory name has a last slash, we only get up to the last character.
        last_sub_unique_directoryname = STRMID(i_unique_clusterjob_directory,pos_of_clusterjob_string,STRLEN(i_unique_clusterjob_directory)-pos_of_clusterjob_string-1);  Get from __clusterjob on, hopefully without the last slash.
    endif else begin
        last_sub_unique_directoryname = STRMID(i_unique_clusterjob_directory,pos_of_clusterjob_string,STRLEN(i_unique_clusterjob_directory)-pos_of_clusterjob_string);  Get from __clusterjob to the end.
    endelse

    big_log_filename = ret_unique_clusterjob_directory + '/task_farm_big_log' + last_sub_unique_directoryname + '.log';
    OPENW, s_log_handle, create_clusterjob_directory(ret_unique_clusterjob_directory) + '/task_farm_big_log' + last_sub_unique_directoryname + '.log', /GET_LUN, ERROR = err_no;

    ; If err_no is nonzero, something happened. Print the error message to  
    ; the standard error file (logical unit -2): 
    if  (err_no NE 0) then begin
        PRINTF, -2, 'idl_monitor_jobs_completion:' + !ERROR_STATE.MSG
    endif
endif

;tstart = systime(1)
;print, 'idl_monitor_jobs_completion: execution start time:', systime()

rat = _logger_print(DEBUG_FLAG,FUNCT_NAME,"INFO","execution start time:" + STRING(systime()));

;exit;

@load_maf_constants

over_all_status = SUCCESS;

; Get the number of lines from file with FILE_LINES() funtion so we can use it to allocate arrays.

MAX_NUM_JOBS = FILE_LINES(i_filelist_name);

; Read the list job completion filename nto memory.

OPENR, file_unit, i_filelist_name, ERROR = err, /GET_LUN;


job_completion_flag_array = LONARR(MAX_NUM_JOBS);  Here, we allocate at most 8 elements, each represent a flag indicating if a job is completed by setting to 1.
job_completion_name_array = STRARR(MAX_NUM_JOBS);  Here, we allocate at most 8 elements, each represent a file name to check indicating if a job is completed.
job_completion_index = 0;
jobs_names_read = 0;

a_file_completion_filename = ""; Note: This assignment is very important to tell IDL that were are dealing with text when we are reading at READF call below.

; Read in all the names we need to check for.

while (~eof(file_unit)) do begin
    ;
    ; Get one file name.  Assumes one file name and a few other attributes per line.
    ; No error handling.
    ;

    READF, file_unit, FORMAT='(A)',a_file_completion_filename;
;print, 'idl_monitor_jobs_completion: a_file_completion_filename [' + a_file_completion_filename + ']';

    rat = _logger_print(DEBUG_FLAG,FUNCT_NAME,"INFO",'a_file_completion_filename [' + a_file_completion_filename + ']');

    job_completion_name_array[job_completion_index] = a_file_completion_filename;
    job_completion_index = job_completion_index + 1;
endwhile

; Close up shop

FREE_LUN, file_unit;

; Get the number of names read by the last value of job_completion_index variable.

jobs_names_read = job_completion_index;

; Now, we enter a forever loop where we check for the job completion until all jobs are completed.
; In between each check, we wait WAIT_DURATION_BETWEEN_CHECKS seconds.

all_jobs_are_completed = 0;
WAIT_DURATION_BETWEEN_CHECKS = 6; seconds per wait loop.
MAX_SECONDS_TO_WAIT = GETENV('GAPRUNNINGTHRESH') * 60; We get the running threshold from the Ancillary Filling run environment.  We don't want this to loop forever.
total_seconds_waited = 0;

rat = _logger_print(DEBUG_FLAG,FUNCT_NAME,"INFO",'Waiting until all ' + STRTRIM(STRING(jobs_names_read),2) + ' job(s) are done...');
while ((all_jobs_are_completed EQ 0) AND (total_seconds_waited LE MAX_SECONDS_TO_WAIT)) do begin

   ; For each name, we check to see if it exists on disk.
   ; If it does, we set the flag to 1.

   for job_completion_index = 0, jobs_names_read - 1 do begin

;      rat = _logger_print(DEBUG_FLAG,FUNCT_NAME,"INFO",'FILE_TEST(' + job_completion_name_array[job_completion_index] + ') [' + STRTRIM(STRING((FILE_TEST(job_completion_name_array[job_completion_index]))),2) + ']'); 

       ; If the name if found, we set the flag bit to 1.
       if (FILE_TEST(job_completion_name_array[job_completion_index])) then begin
           job_completion_flag_array[job_completion_index] = 1;
       endif
   endfor

   ; Here we temporary assume that the jobs are completed.
   ; If any of the flag is zero, we flip it back to false.  Basically, we only consider all jobs are done if each individual job
   ; in array job_completion_flag_array is set to true. 

   optimistic_flag_jobs_done = 1;

   for job_completion_index = 0, jobs_names_read - 1 do begin
       if (job_completion_flag_array[job_completion_index] EQ 0) then begin
           optimistic_flag_jobs_done = 0;
       endif
   endfor

   ; Now, we do a final check to see if all the flags are true via the one flag optimistic_flag_jobs_done
   ; Otherwise, we wait WAIT_DURATION_BETWEEN_CHECKS seconds and check again

   if (optimistic_flag_jobs_done EQ 1) then begin
       ; All the jobs are done, we can now exit this forever loop.
       all_jobs_are_completed = 1;
       rat = _logger_print(DEBUG_FLAG,FUNCT_NAME,"INFO",' All jobs associated with directory ' + i_unique_clusterjob_directory + " are done.");
   endif else begin
;       print,'idl_monitor_jobs_completion: WAIT ', WAIT_DURATION_BETWEEN_CHECKS, ' seconds...';

       ; The job is not done yet, we wait again.

;       rat = _logger_print(DEBUG_FLAG,FUNCT_NAME,"INFO",' WAIT ' + STRTRIM(STRING(WAIT_DURATION_BETWEEN_CHECKS),2) + ' seconds...');
       WAIT, WAIT_DURATION_BETWEEN_CHECKS;

       ; Keep track of how long we have waited so the loop can stop when this value greater than MAX_SECONDS_TO_WAIT.
       total_seconds_waited = total_seconds_waited + WAIT_DURATION_BETWEEN_CHECKS;
   endelse
endwhile;  end while ((all_jobs_are_completed EQ 0) AND (total_seconds_waited LE MAX_SECONDS_TO_WAIT))


errors_occurred_during_execution = 0;  We set this to 1 if the amount waited has passed the maximum wait.

; Check to see if we have waited too long.  Email the operator if this is the case.

if (total_seconds_waited GE MAX_SECONDS_TO_WAIT) then begin
    errors_occurred_during_execution = 1;
    rat = _logger_print(DEBUG_FLAG,FUNCT_NAME,"ERROR","The IDL program may have taken longer than expected: " + STRING(total_seconds_waited) + " seconds" + ", MAX_SECONDS_TO_WAIT = " + STRTRIM(STRING(MAX_SECONDS_TO_WAIT),2) + ".  Please check log file " + big_log_filename + " and associated directory " + i_unique_clusterjob_directory);

    donotcare = idl_email_ops_to_report_error(idl_prepare_email_body("The IDL program may have taken longer than expected: " + STRING(total_seconds_waited) + " seconds" + ", MAX_SECONDS_TO_WAIT = " + STRTRIM(STRING(MAX_SECONDS_TO_WAIT),2) +  ".  Please check log file " + big_log_filename + " and associated directory " + i_unique_clusterjob_directory));
endif


; When all the jobs for this granule are done, we want to signify that this particular partial job is done.
; If string i_sentinel_job_name is empty and errors have occurred during execution, we don't do anything because the user does not intend to have anything done.

if ((i_sentinel_job_name NE "") AND (errors_occurred_during_execution EQ 0)) then begin

    rat = _logger_print(DEBUG_FLAG,FUNCT_NAME,"INFO",'Final EXECUTE command [' + i_sentinel_job_name + "]");

    ; Run this IDL program.

    run_status = EXECUTE(i_sentinel_job_name,1,1);

    if (run_status EQ 0) then begin
        donotcare = idl_email_ops_to_report_error(idl_prepare_email_body(i_sentinel_job_name));
    endif

    ;
    ; Only remove the temporary files if user set the environment GAPMULTIPROCESSESCLEANLOGFILEFLAG to TRUE or true.
    ;

    if ((i_unique_clusterjob_directory NE "") AND (STRUPCASE(GETENV('GAPFARMMULTIPROCESSESCLEANLOGFILEFLAG')) EQ 'TRUE')) then begin

        ; Look for files that start with "tmp_idl".  This is the convention we used to create and delete temporary files.
        ; These temporary files are created in program idl_multi_processes_executor.
 
        file_list_to_delete = FILE_SEARCH(i_unique_clusterjob_directory,"tmp_idl*");

        ;
        ; Delete every temporary files found that starts with 'tmp_idl'.
        ;

        for list_index = 0, N_ELEMENTS(file_list_to_delete) - 1 do begin
            if (STRLEN(file_list_to_delete[list_index]) GT 0) then begin
                FILE_DELETE, file_list_to_delete[list_index], /ALLOW_NONEXISTENT, /QUIET;
            endif else begin
               rat = _logger_print(DEBUG_FLAG,FUNCT_NAME,"ERROR",'File name in variable file_list_to_delete is null, nothing to do.');
            endelse
        endfor

        ;
        ; Now remove hopefully an emptied directory.  If directory it not emptied, it won't do anything.
        ; The /QUIET allows the program to be quiet about attemping to delete a non-empty directory.

        FILE_DELETE, i_unique_clusterjob_directory, /ALLOW_NONEXISTENT, /QUIET;

    endif
endif

;print, 'Overall execution time:', systime(1) - tstart
;help,/heap

;
; Close up shop.  Note, this file unit/handle must be closed/freed before the file can be deleted.
;
if (s_log_handle NE BOGUS_LOG_HANDLE) then begin
    FREE_LUN, s_log_handle;
endif


;
; Delete the big log as well.
;
if ((i_unique_clusterjob_directory NE "") AND (STRUPCASE(GETENV('GAPFARMMULTIPROCESSESCLEANLOGFILEFLAG')) EQ 'TRUE')) then begin
    ; Only delete the big blog if no error has occurred otherwise leave it alone.
    if (errors_occurred_during_execution EQ 0) then begin
        FILE_DELETE, big_log_filename, /ALLOW_NONEXISTENT, /QUIET
    endif
endif

END
