;  Copyright 2015, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id$
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

FUNCTION write_gds2_normal_variable,$
             i_filename,$
             i_dataset_array,$
             i_dataset_short_name,$
             i_standard_name,$
             i_units,$
             i_fill_value,$
             i_data_type,$
             i_valid_min,$
             i_valid_max,$
             i_comment,$
             i_long_name,$
             i_slope,$
             i_intercept,$
             i_source,$
             i_coordinates,$
             i_flag_values,$
             i_flag_meanings,$
             i_grid_mapping,$
             i_time_offset,$
             i_height,$
             i_flag_masks

; Function write one MODIS data variable along with its attributes to an existing NetCDF file in GDS2 format.
;
; Assumptions:
;
;   1. The NetCDF file exist.
;   2. The lat and lon ids have been defined for the size of the variable.  
;

;------------------------------------------------------------------------------------------------

; Load constants.

@data_const_config.cfg

; Define local variables.

o_status = SUCCESS;

; Get the DEBUG_MODE if it is set.

debug_module = 'write_gds2_normal_variable:';
debug_mode = 0
if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_DEBUG_MODE')) EQ 'TRUE') then begin
    debug_mode = 1; 
endif

;debug_mode = 1;

; Check to see if the compression is suppressed.  If it on by default.

compression_flag = 1; By default, we will use the compression chunking if possible.
if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_CHUNKING_SUPPRESS')) EQ 'TRUE') then begin
    compression_flag = 0;
endif

; Check to see if the GZIP compression level is set.  It is default to 5.

compression_level = 5;
if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_CHUNKING_COMPRESSION_LEVEL')) NE '') then begin
    compression_level = FIX(GETENV('GHRSST_MODIS_L2P_CHUNKING_COMPRESSION_LEVEL'));
endif

; Create a catch block to catch error in interaction with FILE IO
CATCH, error_status
if (error_status NE 0) then begin
    CATCH, /CANCEL
    print, 'write_gds2_normal_variable: ERROR, Cannot open file for update ' + i_filename;
    o_status = FAILURE;
    ; Must return immediately.
    return, o_status
endif

;
; Open NetCDF file for update. 
;

file_id = NCDF_OPEN(i_filename,/WRITE);

;
; Put NetCDF file into define mode for writing:
;

CATCH, error_status
if (error_status NE 0) then begin
    CATCH, /CANCEL
    print, 'write_gds2_normal_variable: ERROR, Cannot set NetCDF file into define mode file ' + i_filename
    o_status = FAILURE;
    ; Must return immediately.
    return, o_status
endif

if (debug_mode) then print, debug_module + 'Putting into define mode for writing variable ' + i_dataset_short_name + ' to file ' + i_filename; 
NCDF_CONTROL, file_id, /REDEF
CATCH, /CANCEL

;
; Get the id's of the lat and lon from file.
;

CATCH, error_status
if (error_status NE 0) then begin
    CATCH, /CANCEL
    print, 'write_gds2_normal_variable: ERROR, Cannot get the ids for lat, lon and time dimensions in file ' + i_filename;
    o_status = FAILURE;
    ; Must return immediately.
    return, o_status
endif
dataset_lat_id = NCDF_DIMID(file_id,'nj');
dataset_lon_id = NCDF_DIMID(file_id,'ni');
dataset_time_id = NCDF_DIMID(file_id,'time');
CATCH, /CANCEL

CATCH, error_status
if (error_status NE 0) then begin
    CATCH, /CANCEL
    print, 'write_gds2_normal_variable: ERROR, Function NCDF_DIMINQ failed for lat, lon and time ids in file ' + i_filename;
    o_status = FAILURE;
    ; Must return immediately.
    return, o_status
endif

; Get the dimension sizes so we can pass it onto NCDF_VARDEF function.

NCDF_DIMINQ, file_id, dataset_lat_id, lat_variable_name,  lat_size
NCDF_DIMINQ, file_id, dataset_lon_id, lon_variable_name,  lon_size
NCDF_DIMINQ, file_id, dataset_time_id,time_variable_name, time_size
CATCH, /CANCEL

; Set the chunk_dimension_vector to pass it onto NCDF_VARDEF function for the infile compression.

chunk_dimension_vector = [lon_size,lat_size,1]

; Tweak the chunk dimension if we can divide lon_size by 2

modulo_of_lon = lon_size MOD 2;
modulo_of_lat = lat_size MOD 2;
if ((modulo_of_lon EQ 0) AND (modulo_of_lat EQ 0))  then begin
    chunk_dimension_vector = [lon_size/2,lat_size/2,1];
endif

if (debug_mode) then begin
    print, debug_module + 'modulo_of_lon      = ', modulo_of_lon;
    print, debug_module + 'modulo_of_lat      = ', modulo_of_lat;
    print, debug_module + 'lat_variable_name  = ', lat_variable_name, ' lat_size ', lat_size
    print, debug_module + 'lon_variable_name  = ', lon_variable_name, ' lon_size ', lon_size
    print, debug_module + 'time_variable_name = ', time_variable_name, ' time_size ', time_size
    print, debug_module + 'i_data_type        = ', i_data_type
    print, debug_module + 'i_dataset_short_name = ', i_dataset_short_name 
endif

CATCH, error_status
if (error_status NE 0) then begin
    CATCH, /CANCEL
    print, 'write_gds2_normal_variable: ERROR, Cannot create variable ' + i_dataset_short_name + ' in file ' + i_filename;
    o_status = FAILURE;
    ; Must return immediately.
    return, o_status
endif

;
; Create the id for the dataset. Be careful, the 3rd argument has
; lat id, lon id, and time id respectively.
;

if (i_data_type EQ 'LONG') then begin
    ; We make special case for 'time' variable since it is only one dimension.
    if (i_dataset_short_name EQ 'time') then begin
        chunk_dimension_vector = [1];  The time variable is only one dimension.
        if (compression_flag) then begin
            dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_time_id], /LONG, GZIP=compression_level, CHUNK_DIMENSIONS=chunk_dimension_vector);
        endif else begin
            dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_time_id], /LONG);
        endelse
    endif else begin
        if (compression_flag) then begin
            dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_lon_id,dataset_lat_id,dataset_time_id], /LONG, GZIP=compression_level, CHUNK_DIMENSIONS=chunk_dimension_vector);
        endif else begin
            dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_lon_id,dataset_lat_id,dataset_time_id], /LONG);
        endelse
    endelse
endif else begin
    if (i_data_type EQ 'SHORT') then begin
        if (compression_flag) then begin
            dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_lon_id,dataset_lat_id,dataset_time_id], /SHORT, GZIP=compression_level, CHUNK_DIMENSIONS=chunk_dimension_vector);
        endif else begin
            dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_lon_id,dataset_lat_id,dataset_time_id], /SHORT);
        endelse
    endif else begin
        if (i_data_type EQ 'FLOAT') then begin
            if (compression_flag) then begin
                dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_lon_id,dataset_lat_id,dataset_time_id], /FLOAT, GZIP=compression_level, CHUNK_DIMENSIONS=chunk_dimension_vector);
            endif else begin
                dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_lon_id,dataset_lat_id,dataset_time_id], /FLOAT);
            endelse
        endif else begin
            if (i_data_type EQ 'INT') then begin
                if (compression_flag) then begin
                    dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_lon_id,dataset_lat_id,dataset_time_id], /SHORT, GZIP=compression_level, CHUNK_DIMENSIONS=chunk_dimension_vector);
                endif else begin
                    dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_lon_id,dataset_lat_id,dataset_time_id], /SHORT);
                endelse
            endif else begin
                if (i_data_type EQ 'BYTE') then begin
                     if (compression_flag) then begin
                         dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_lon_id,dataset_lat_id, dataset_time_id], /BYTE, GZIP=compression_level, CHUNK_DIMENSIONS=chunk_dimension_vector);
                     endif else begin
                         dataset_id = NCDF_VARDEF(file_id, i_dataset_short_name, [dataset_lon_id,dataset_lat_id, dataset_time_id], /BYTE);
                     endelse
                endif else begin
                    print, 'write_gds2_normal_variable: ERROR, data type not supported at this point. i_data_type = ', i_data_type;
                endelse
             endelse
        endelse
    endelse
endelse 
CATCH, /CANCEL


; Because the function NCDF_VARDEF does not throw an exception, we have to check for the validity of the dataset_id.
; If it is -1, close the file and return.
if (dataset_id EQ -1) then begin
    print, 'write_gds2_normal_variable: ERROR, Cannot define variable ' + i_dataset_short_name + ' for file ' + i_filename;
    o_status = FAILURE;
    NCDF_CLOSE, file_id;
    CATCH, /CANCEL
    ; Must return immediately.
    return, o_status
endif


;
; Define attributes for the data set variable.
;

CATCH, error_status
if (error_status NE 0) then begin
    CATCH, /CANCEL
    print, 'write_gds2_normal_variable: ERROR, Cannot write attributes for file ' + i_filename;
    o_status = FAILURE;
    ; Must return immediately.
    return, o_status
endif

if (N_ELEMENTS(i_long_name)) then begin
    if (debug_mode) then print, debug_module + 'Writing attribute long_name with value [' + i_long_name + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
    NCDF_ATTPUT,file_id,dataset_id,"long_name",i_long_name;
endif

if (N_ELEMENTS(i_standard_name)) then begin
    if (debug_mode) then print, debug_module + 'Writing attribute standard_name with value [' + i_standard_name + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
    NCDF_ATTPUT,file_id,dataset_id,"standard_name",i_standard_name;
endif

if (N_ELEMENTS(i_units)) then begin
    if (debug_mode) then print, debug_module + 'Writing attribute units with value [' + i_units + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
    NCDF_ATTPUT,file_id,dataset_id,"units",i_units;
endif

if (N_ELEMENTS(i_fill_value)) then begin
    if (i_data_type EQ 'LONG') then begin
        if (debug_mode) then print, debug_module + 'Writing attribute _FillValue with value [' + STRING(i_fill_value) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"_FillValue",i_fill_value, /LONG;
    endif
    if ((i_data_type EQ 'INT') OR (i_data_type EQ 'SHORT')) then begin
        if (debug_mode) then print, debug_module + 'Writing attribute _FillValue with value [' + STRING(i_fill_value) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"_FillValue",i_fill_value, /SHORT;
    endif
    if (i_data_type EQ 'BYTE') then begin
        ; When printing an attribute of type BYTE, must use /PRINT in the STRING() function to print it correctly.
        if (debug_mode) then print, debug_module + 'Writing attribute _FillValue with value [' + STRING(i_fill_value,/PRINT) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"_FillValue",i_fill_value, /BYTE;
    endif
    if (i_data_type EQ 'FLOAT') then begin
        if (debug_mode) then print, debug_module + 'Writing attribute _FillValue with value [' + STRING(i_fill_value) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"_FillValue",i_fill_value, /FLOAT;
    endif
endif

if (N_ELEMENTS(i_valid_min)) then begin
    if (i_data_type EQ 'LONG') then begin
        if (debug_mode) then print, debug_module + 'Writing attribute valid_min with value [' + STRING(i_valid_min) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"valid_min",i_valid_min, /LONG;
    endif
    if ((i_data_type EQ 'INT') OR (i_data_type EQ 'SHORT')) then begin
        ; We make special case for l2p_flags because these values are unsigned integer.
        if (i_dataset_short_name EQ 'l2p_flags') then begin
            if (debug_mode) then print, debug_module + 'Writing attribute valid_min with value [' + STRING(i_valid_min) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
            NCDF_ATTPUT,file_id,dataset_id,"valid_min",i_valid_min;
        endif else begin
            if (debug_mode) then print, debug_module + 'Writing attribute valid_min with value [' + STRING(i_valid_min) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
            NCDF_ATTPUT,file_id,dataset_id,"valid_min",i_valid_min, /SHORT;
        endelse
    endif
    if (i_data_type EQ 'BYTE') then begin
        ; When printing an attribute of type BYTE, must use /PRINT in the STRING() function to print it correctly.
        if (debug_mode) then print, debug_module + 'Writing attribute valid_min with value [' + STRING(i_valid_min,/PRINT) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"valid_min",i_valid_min, /BYTE;
    endif
    if (i_data_type EQ 'FLOAT') then begin
        if (debug_mode) then print, debug_module + 'Writing attribute valid_min with value [' + STRING(i_valid_min) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"valid_min",i_valid_min, /FLOAT;
    endif
endif

if (N_ELEMENTS(i_valid_max)) then begin
    if (i_data_type EQ 'LONG') then begin
        if (debug_mode) then print, debug_module + 'Writing attribute valid_max with value [' + STRING(i_valid_max) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"valid_max",i_valid_max, /LONG;
    endif
    if ((i_data_type EQ 'INT') OR (i_data_type EQ 'SHORT')) then begin
        ; We make special case for l2p_flags because these values are unsigned integer.
        if (i_dataset_short_name EQ 'l2p_flags') then begin
            if (debug_mode) then print, debug_module + 'Writing attribute valid_max with value [' + STRING(i_valid_max) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
            NCDF_ATTPUT,file_id,dataset_id,"valid_max",i_valid_max;
        endif else begin
            if (debug_mode) then print, debug_module + 'Writing attribute valid_max with value [' + STRING(i_valid_max) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
            NCDF_ATTPUT,file_id,dataset_id,"valid_max",i_valid_max, /SHORT;
        endelse
    endif
    if (i_data_type EQ 'BYTE') then begin
        ; When printing an attribute of type BYTE, must use /PRINT in the STRING() function to print it correctly.
        if (debug_mode) then print, debug_module + 'Writing attribute valid_max with value [' + STRING(i_valid_max,/PRINT) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"valid_max",i_valid_max, /BYTE;
    endif
    if (i_data_type EQ 'FLOAT') then begin
        if (debug_mode) then print, debug_module + 'Writing attribute valid_max with value [' + STRING(i_valid_max) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"valid_max",i_valid_max, /FLOAT;
    endif
endif

if (N_ELEMENTS(i_comment)) then begin
    if (debug_mode) then print, debug_module + 'Writing attribute comment with value [' + STRING(i_comment) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
    NCDF_ATTPUT,file_id,dataset_id,"comment",i_comment;
endif

; Date: 4/26/2017
; Correction: Both of the attributes need to be check together (i.e. using AND logic)
if ((N_ELEMENTS(i_slope)) and N_ELEMENTS(i_intercept)) then begin
    ; NASA best practice says that when the scalefactor is 1 and the addoffset is 0, there is no need to include them
    if (i_slope EQ 1) and (i_intercept EQ 0) then begin
        ; Do nothing if scale_factor is 1 and slope is 0
    endif else begin
        ; Writing both attributes since they are defined and NOT ((i_slope EQ 1) and (i_intercept EQ 0))
        if (debug_mode) then print, debug_module + 'Writing attribute scale_factor with value [' + STRING(i_slope) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"scale_factor",i_slope;
        NCDF_ATTPUT,file_id,dataset_id,"add_offset",i_intercept;
    endelse
endif

if (N_ELEMENTS(i_source)) then begin
    if (i_source NE '') then begin
        if (debug_mode) then print, debug_module + 'Writing attribute source with value [' + STRING(i_source) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"source",i_source;
    endif else begin
        if (debug_mode) then print, debug_module + 'Skipping attribute source with value [' + STRING(i_source) + '] of variable ' + i_dataset_short_name + ' since it is empty string, ' + ' to file ' + i_filename; 
    endelse
endif

if (N_ELEMENTS(i_coordinates)) then begin
    if (i_coordinates NE '') then begin
        if (debug_mode) then print, debug_module + 'Writing attribute coordinates with value [' + STRING(i_coordinates) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
        NCDF_ATTPUT,file_id,dataset_id,"coordinates",i_coordinates;
    endif else begin
        if (debug_mode) then print, debug_module + 'Skipping attribute coordinates with value [' + STRING(i_coordinates) + '] of variable ' + i_dataset_short_name + ' since it is empty string, ' + ' to file ' + i_filename; 
    endelse
endif

; Because the value i_flag_values is an array, we look to see if contains more than 0 element instead of 1 element.
if (N_ELEMENTS(i_flag_values) GT 0) then begin
    ; When printing an attribute of type BYTE, must use /PRINT in the STRING() function to print it correctly.
    if (debug_mode) then print, debug_module + 'Writing attribute flag_values with value [' + STRING(i_flag_values,/PRINT) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
    NCDF_ATTPUT,file_id,dataset_id,"flag_values",i_flag_values, /BYTE;
endif

if (N_ELEMENTS(i_flag_meanings)) then begin
    if (debug_mode) then print, debug_module + 'Writing attribute flag_meanings with value [' + STRING(i_flag_meanings) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
    NCDF_ATTPUT,file_id,dataset_id,"flag_meanings",i_flag_meanings;
endif

if (N_ELEMENTS(i_grid_mapping)) then begin
    if (debug_mode) then print, debug_module + 'Writing attribute grid_mapping with value [' + STRING(i_grid_mapping) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
    NCDF_ATTPUT,file_id,dataset_id,"grid_mapping",i_grid_mapping;
endif

if (N_ELEMENTS(i_time_offset)) then begin
    if (debug_mode) then print, debug_module + 'Writing attribute time_offset with value [' + STRING(i_time_offset) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
    NCDF_ATTPUT,file_id,dataset_id,"time_offset",i_time_offset;
endif

if (N_ELEMENTS(i_height)) then begin
    if (debug_mode) then print, debug_module + 'Writing attribute height with value [' + STRING(i_height) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
    NCDF_ATTPUT,file_id,dataset_id,"height",i_height;
endif

; Because the value i_flag_masks is an array, we look to see if contains more than 0 element instead of 1 element.
if (N_ELEMENTS(i_flag_masks) GT 0) then begin
    if (debug_mode) then print, debug_module + 'Writing attribute flag_masks with value [' + STRING(i_flag_masks) + '] to variable ' + i_dataset_short_name + ' to file ' + i_filename; 
    NCDF_ATTPUT,file_id,dataset_id,"flag_masks",i_flag_masks;
endif
CATCH, /CANCEL

; Add an additional attribute: 11/14/2019

if (STRUPCASE(GETENV('GHRSST_WRITE_COVERAGE_CONTENT_TYPE_FLAG')) EQ 'TRUE') then begin
    NCDF_ATTPUT,file_id,dataset_id,"coverage_content_type",get_coverage_content_type(i_dataset_short_name);
endif

;
; Put NetCDF file out of define mode and into data mode for writing:
;

CATCH, error_status
if (error_status NE 0) then begin
    CATCH, /CANCEL
    print, 'write_gds2_normal_variable: ERROR, Cannot set NetCDF file into data mode for file ' + i_filename;
    o_status = FAILURE;
    ; Must return immediately.
    return, o_status
endif

if (debug_mode) then print, debug_module + 'Putting into data mode for writing variable ' + i_dataset_short_name + ' to file ' + i_filename; 
NCDF_CONTROL, file_id, /ENDEF
CATCH, /CANCEL

;
; Write the data set to NetCDF file.
;

CATCH, error_status
if (error_status NE 0) then begin
    CATCH, /CANCEL
    print, 'write_gds2_normal_variable: ERROR, Cannot write dataset ' + i_dataset_short_name + ' to NetCDF file ' + i_filename;
    o_status = FAILURE;
    NCDF_CLOSE, file_id
    CATCH, /CANCEL
    ; Must return immediately.
    return, o_status
endif

if (debug_mode) then print, debug_module + 'Writing variable ' + i_dataset_short_name + ' to file ' + i_filename; 
NCDF_VARPUT, file_id, dataset_id, i_dataset_array;
CATCH, /CANCEL

; ---------- Close up shop ---------- 
if (debug_mode) then print, debug_module + 'Closing file pointer after writing variable ' + i_dataset_short_name + ' to file ' + i_filename; 
NCDF_CLOSE, file_id
CATCH, /CANCEL
return, o_status
end
