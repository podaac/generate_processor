;  Copyright 2005, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id: convert_additional_night_hdf_variables.pro,v 1.11 2007/09/19 20:46:58 qchau Exp $
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CVS
; New Request #xxxx

FUNCTION convert_additional_night_hdf_variables,i_filename,i_out_filename,$
             i_num_lons,$
             i_num_lats,$
             i_convert_to_kelvin, $
             i_num_bad_scan_lines, $
             i_bad_scan_lines_array,$
             i_test_parameter

; Function convert additional HDF variables to NetCDF if the data was marked as "Night" or "Mixed".
;
; Assumptions and notes:
;
;   1. Modifications were made in 5/2014 to add more error handlings;
;
;       https://podaac-redmine.jpl.nasa.gov/issues/2349 MODIS Level 2 Combiner and MODIS Level 2P Processing to read supporting attributes
;
;      The steps will be preceded with MODIS_L2P_ERROR_STEP n to allow easy search.
;------------------------------------------------------------------------------------------------

; Load constants.

@modis_data_config.cfg

; Define local variables.

r_status = SUCCESS;

; Set our test parameter based on what's being passed in,
TEST_PARAMETER = STRUPCASE(GETENV('TEST_PARAMETER_STR'))
if (N_ELEMENTS(i_test_parameter) NE 0) then begin
    TEST_PARAMETER = i_test_parameter;
endif

routine_name = "convert_additional_night_hdf_variables";
msg_type = "";
msg = ""
i_data = "";

debug_mode = 0;

; A few extra parameters to signify if a particular variable should be written out or not.
; If we cannot read a variable in, we cannot do anything with it including writing it out.

ok_to_write_sst4_flag      = 0;
ok_to_write_bias_sst4_flag = 0;
ok_to_write_stdv_sst4_flag = 0;
ok_to_write_qual_sst4_flag = 0;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Read additional night arrays from HDF file and write to NetCDF file.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

i_variable_short_name = 'sst4';

; Check first to see if the variable exist.  If it does, we will attempt to read it.
; Otherwise, don't try to read it.
variable_exist_flag = is_hdf_variable_in_file($
                          i_filename,$
                          i_variable_short_name);

if (debug_mode) then begin
print, 'i_filename ', i_filename, ' i_variable_short_name ', i_variable_short_name, ' variable_exist_flag ', variable_exist_flag
endif

; BEGIN_CHECK_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------
if (variable_exist_flag) then begin

status = read_hdf_variable(i_filename,i_variable_short_name,$
                           r_dataset_array, r_slope,$
                           r_intercept,r_data_type,r_fill_value,r_valid_min,r_valid_max);

ok_to_write_sst4_flag = 1;

if (TEST_PARAMETER EQ "BAD_SST4_VARIABLE_READ") then begin
    status = FAILURE;
endif

if (debug_mode) then begin
    print, 'i_filename ', i_filename, ' i_variable_short_name ', i_variable_short_name, ' variable_exist_flag ', variable_exist_flag, ' TEST_PARAMETER ', TEST_PARAMETER, ' status ', status
endif

; MODIS_L2P_ERROR_STEP 18: If cannot read optional additional night variable 'sst4' from night file, WARN sigevent thrown, keep going 

if (status NE SUCCESS) then begin
    msg_type = "warning";
    msg = 'Failed in ' + routine_name + ' to read variable ' + i_variable_short_name + ' in file ' + i_filename;
    print, msg;
    donotcare = wrapper_ghrsst_notify_operator($
                    routine_name,$
                    msg_type,$
                    msg,$
                    i_data);
    ok_to_write_sst4_flag = 0;  We won't be doing anything with the sst4 variable.
    ; Keep going
endif; end if ((status NE SUCCESS)

if (ok_to_write_sst4_flag) then begin
;
; Save the 'sst4' array for later processing.
;

saved_sst4_array = r_dataset_array;

i_dataset_name = 'sea_surface_temperature4';
if (strcmp(i_convert_to_kelvin,'yes')) then begin
    i_units = 'kelvin';
    r_intercept += CELSIUS_TO_KELVIN_CONVERSION_FACTOR;
end else begin
    i_units = 'celsius';
endelse

; If the fill value is provided from HDF file, we attempt to use it
if (N_ELEMENTS(r_fill_value)) then begin
    ; Do nothing, the variable r_fill_value is already contained the value we want.
endif else begin
    ; If the fill value is not provided, we use a constant, which is hard-coded.
    r_fill_value = MISSING_VALUE_SST;
endelse

; If the valid_min value is provided from HDF file, we attempt to use it

if (N_ELEMENTS(r_valid_min)) then begin
    ; Do nothing, the variable is already contained the value we want.
endif else begin
    ; If the value is not provided, we use a constant, which is hard-coded.
    r_valid_min = -1000;
endelse

; If the valid_max value is provided from HDF file, we attempt to use it

if (N_ELEMENTS(r_valid_max)) then begin
    ; Do nothing, the variable is already contained the value we want.
endif else begin
    ; If the value is not provided, we use a constant, which is hard-coded.
    r_valid_max = 8000;
endelse

i_coordinates = "lon lat";
i_long_name =  'sea surface temperature';
i_source = '';
i_comment = 'sea surface temperature from mid-IR (4 um) channels; non L2P core field';

;l_status = fill_bad_scan_lines_with_missing_value(i_dataset_name,$
;                i_num_bad_scan_lines, $
;                i_bad_scan_lines_array, $
;                r_fill_value, $
;                r_dataset_array);

status = write_modis_data_variable(i_out_filename,$
                                   r_dataset_array,$
                                   i_dataset_name,$
                                   i_long_name,$
                                   i_units,$
                                   r_slope,r_intercept,$
                                   r_fill_value,r_data_type,$
                                   r_valid_min,r_valid_max,i_coordinates,i_source,i_comment);
endif; end if (ok_to_write_sst4_flag)
endif; end if (variable_exist_flag

; END_CHECK_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------

;--------------------------------------------------------------------------------
; Read bias_sst4 from HDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'bias_sst4';

; Check first to see if the variable exist.  If it does, we will attempt to read it.
; Otherwise, don't try to read it.

variable_exist_flag = is_hdf_variable_in_file($
                          i_filename,$
                          i_variable_short_name);

; BEGIN_CHECK_BIAS_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------
if (variable_exist_flag) then begin

status = read_hdf_variable(i_filename,i_variable_short_name,$
                           r_bias_sst4, r_slope_bias_error,$
                           r_intercept_bias_error,r_data_type);

ok_to_write_bias_sst4_flag = 1;

if (TEST_PARAMETER EQ "BAD_BIAS_SST4_VARIABLE_READ") then begin
    status = FAILURE;
endif

if (debug_mode) then begin
    print, 'i_filename ', i_filename, ' i_variable_short_name ', i_variable_short_name, ' variable_exist_flag ', variable_exist_flag, ' TEST_PARAMETER ', TEST_PARAMETER, ' status ', status
endif

; MODIS_L2P_ERROR_STEP 19: If cannot read optional additional night variable 'bias_sst4' from night file, WARN sigevent thrown, keep going

if (status NE SUCCESS) then begin
    msg_type = "warning";
    msg = 'Failed in ' + routine_name + ' to read variable ' + i_variable_short_name + ' in file ' + i_filename;
    print, msg;
    donotcare = wrapper_ghrsst_notify_operator($
                    routine_name,$
                    msg_type,$
                    msg,$
                    i_data);
    ok_to_write_bias_sst4_flag = 0;
    ; Keep going
endif
endif; end if (variable_exist_flag)
; END_CHECK_BIAS_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------

;--------------------------------------------------------------------------------
; Read stdv_sst4 from HDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'stdv_sst4';

; Check first to see if the variable exist.  If it does, we will attempt to read it.
; Otherwise, don't try to read it.
variable_exist_flag = is_hdf_variable_in_file($
                          i_filename,$
                          i_variable_short_name);

; BEGIN_CHECK_STDV_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------
if (variable_exist_flag) then begin

status = read_hdf_variable(i_filename,i_variable_short_name,$
                           r_stdv_sst4, r_slope_standard_deviation_sst,$
                           r_intercept_standard_deviation_sst,r_data_type);

ok_to_write_stdv_sst4_flag = 1;

if (TEST_PARAMETER EQ "BAD_STDV_SST4_VARIABLE_READ") then begin
    status = FAILURE;
endif

if (debug_mode) then begin
    print, 'i_filename ', i_filename, ' i_variable_short_name ', i_variable_short_name, ' variable_exist_flag ', variable_exist_flag, ' TEST_PARAMETER ', TEST_PARAMETER, ' status ', status
endif

; MODIS_L2P_ERROR_STEP 20: If cannot read optional additional night variable 'stdv_sst4' from night file, WARN sigevent thrown, keep going 

if (status NE SUCCESS) then begin
    msg_type = "warning";
    msg = 'Failed in ' + routine_name + ' to read variable ' + i_variable_short_name + ' in file ' + i_filename;
    print, msg;
    donotcare = wrapper_ghrsst_notify_operator($
                    routine_name,$
                    msg_type,$
                    msg,$
                    i_data);
    ok_to_write_stdv_sst4_flag = 0;
    ; Keep going
endif
endif; end if (variable_exist_flag) 
; END_CHECK_STDV_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------

; Read qual_sst4 from HDF file and write to NetCDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'qual_sst4';

; Check first to see if the variable exist.  If it does, we will attempt to read it.
; Otherwise, don't try to read it.
variable_exist_flag = is_hdf_variable_in_file($
                          i_filename,$
                          i_variable_short_name);

; BEGIN_CHECK_QUAL_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------
if (variable_exist_flag) then begin

status = read_hdf_variable(i_filename,i_variable_short_name,$
                           r_qual_sst4, r_slope,$
                           r_intercept,r_data_type);

ok_to_write_qual_sst4_flag = 1;

if (TEST_PARAMETER EQ "QUAL_STDV_SST4_VARIABLE_READ") then begin
    status = FAILURE;
endif

if (debug_mode) then begin
    print, 'i_filename ', i_filename, ' i_variable_short_name ', i_variable_short_name, ' variable_exist_flag ', variable_exist_flag, ' TEST_PARAMETER ', TEST_PARAMETER, ' status ', status
endif

; MODIS_L2P_ERROR_STEP 21: If cannot read optional additional night variable 'qual_sst4'from night file, WARN sigevent thrown, keep going

if (status NE SUCCESS) then begin
    msg_type = "warning";
    msg = 'Failed in ' + routine_name + ' to read variable ' + i_variable_short_name + ' in file ' + i_filename;
    print, msg;
    donotcare = wrapper_ghrsst_notify_operator($
                    routine_name,$
                    msg_type,$
                    msg,$
                    i_data);
    ok_to_write_qual_sst4_flag = 0;
    ; Keep going 
endif
endif; end  if (variable_exist_flag)
; BEGIN_CHECK_QUAL_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------


if ((ok_to_write_sst4_flag) AND (ok_to_write_bias_sst4_flag)) then begin
; Build an array to update the elements with.

if (ok_to_write_qual_sst4_flag) then begin
r_updated_qual_sst4 = r_qual_sst4;

if (ok_to_write_stdv_sst4_flag) then begin
if ((ok_to_write_sst4_flag) AND (ok_to_write_bias_sst4_flag)) then begin
status = perform_proximity_confidence_mapping(i_num_lons,i_num_lats,$
             saved_sst4_array,$
             r_qual_sst4,$
             r_bias_sst4,$
             r_stdv_sst4,$
             r_updated_qual_sst4);
endif

i_dataset_name = 'proximity_confidence4';
i_units = 'dimensionless';
r_fill_value = MISSING_VALUE_PROXIMITY_CONFIDENCE;
i_valid_min = 0B;
i_valid_max = 6B;
i_coordinates = "lon lat";
i_long_name =  'proximity confidence value';
i_comment =  "mid-IR SST proximity confidence value; non L2P core field; signed byte array:  WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";

status = write_modis_data_variable(i_out_filename,$
                                   r_updated_qual_sst4,$
                                   i_dataset_name,$
                                   i_long_name,$
                                   i_units,$
                                   r_slope,r_intercept,$
                                   r_fill_value,r_data_type,$
                                   i_valid_min,i_valid_max,i_coordinates,i_source,i_comment);
endif; end if  (ok_to_write_qual_sst4_flag)
endif; end if ((ok_to_write_sst4_flag) AND (ok_to_write_bias_sst4_flag))
endif; end if (ok_to_write_stdv_sst4_flag)

if ((ok_to_write_sst4_flag) AND (ok_to_write_bias_sst4_flag)) then begin
;
; Write the other byte arrays.
;

i_dataset_name = 'SSES_bias_error4';
if (i_convert_to_kelvin EQ 'yes') then begin
    i_units = 'kelvin';
end else begin
    i_units = 'celsius';
end

r_fill_value = BYTE_FILL_VALUE;
i_valid_min =  -127B; 
i_valid_max = SIGNED_BYTE_VALID_MAX; place holder
i_coordinates = "lon lat";
i_long_name =  'SSES bias error based on proximity confidence flags';
i_source = '';
i_comment =  "mid-IR SST bias error; non L2P core field; signed byte array:  WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";

size_array = size(r_bias_sst4);
num_columns = size_array[1];
num_rows    = size_array[2];
r_bias_sst4_as_int = INTARR(num_columns,num_rows,/NOZERO);

;l_status = fill_bad_scan_lines_with_missing_value(i_dataset_name,$
;                i_num_bad_scan_lines, $
;                i_bad_scan_lines_array, $
;                r_fill_value, $
;                r_bias_sst4);

; If we are not processing from original NetCDF file, use the "converted" intercept value. 
if (GETENV('GHRSST_MODIS_L2P_CONVERTING_FROM_ORIGINAL_NETCDF_FILES') NE 'true') then begin
    use_this_intercept_bias_error = r_intercept_bias_error;
    l_status = convert_to_signed_byte(r_bias_sst4,r_intercept_bias_error,r_bias_sst4_as_int);
    status = write_modis_data_variable(i_out_filename,$
                 r_bias_sst4_as_int,$
                 i_dataset_name,$
                 i_long_name,$
                 i_units,$
                 r_slope_bias_error,r_intercept_bias_error,$
                 r_fill_value,r_data_type,$
                 i_valid_min,i_valid_max,i_coordinates,i_source,i_comment);
endif else begin
    ; If we are processing from original NetCDF file, use the different scaling to convert from short to byte and also reset the scale factor and offset.
    scaling_status = apply_scaling_from_short_to_byte($
                         r_slope_bias_error,$
                         r_bias_sst4,$
                         o_byte_variable_array,$
                         o_byte_scale_factor,$
                         o_byte_add_offset);

if (debug_mode) then begin
print, 'Content of original short variable from NetCDF file:'
print, '          r_slope_bias_error          = ', r_slope_bias_error;
print, '          r_intercept_bias_error      = ', r_intercept_bias_error;   
print, 'ORIGINAL  : r_bias_sst4[0,0]           = ', r_bias_sst4[0,0];
print, 'CALCULATED: r_bias_sst4[0,0]*r_slope_bias_error + r_intercept_bias_error = ', r_bias_sst4[0,0] * r_slope_bias_error + r_intercept_bias_error;   
print, ''
print, 'Content of scaled byte variable to be written to NetCDF file:'
print, '          o_byte_scale_factor              = ', o_byte_scale_factor;
print, '          o_byte_add_offset                = ', o_byte_add_offset;   
print, 'ORIGINAL  o_byte_variable_array[0,0]) = ', o_byte_variable_array[0,0]
print, 'CALCULATED:o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset     = ', o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset;
endif

    status = write_modis_data_variable(i_out_filename,$
                 o_byte_variable_array,$
                 i_dataset_name,$
                 i_long_name,$
                 i_units,$
                 o_byte_scale_factor,o_byte_add_offset,$
                 r_fill_value,r_data_type,$
                 i_valid_min,i_valid_max,i_coordinates,i_source,i_comment);
endelse
endif; end if ((ok_to_write_sst4_flag) AND (ok_to_write_bias_sst4_flag))


if (ok_to_write_stdv_sst4_flag) then begin
i_dataset_name = 'SSES_standard_deviation_error4';
if (i_convert_to_kelvin EQ 'yes') then begin
    i_units = 'kelvin';
end else begin
    i_units = 'celsius';
end

r_fill_value = BYTE_FILL_VALUE;
i_valid_min =  -127B; 
i_valid_max = SIGNED_BYTE_VALID_MAX; place holder
i_coordinates = 'lon lat';
i_long_name =  'SSES standard deviation error based on proximity confidence flags';
i_source = '';
i_comment =  "mid-IR SST standard deviation error; non L2P core field; signed byte array:  WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";

; Because the variable r_bias_sst4 may not have been read successfully, we get the num_columns and num_rows from variable r_stdv_sst4
size_array = size(r_stdv_sst4);
num_columns = size_array[1];
num_rows    = size_array[2];
r_stdv_sst4_as_int = INTARR(num_columns,num_rows,/NOZERO);

; If we are not processing from original NetCDF file, use the "converted" intercept value. 
if (GETENV('GHRSST_MODIS_L2P_CONVERTING_FROM_ORIGINAL_NETCDF_FILES') NE 'true') then begin
status = convert_to_signed_byte(r_stdv_sst4,r_intercept_standard_deviation_sst,r_stdv_sst4_as_int);
status = write_modis_data_variable(i_out_filename,$
             r_stdv_sst4_as_int,$
             i_dataset_name,$
             i_long_name,$
             i_units,$
             r_slope_standard_deviation_sst,r_intercept_standard_deviation_sst,$
             r_fill_value,r_data_type,$
             i_valid_min,i_valid_max,i_coordinates,i_source,i_comment);
endif else begin
    ; If we are processing from original NetCDF file, use the different scaling to convert from short to byte and also reset the scale factor and offset.
    scaling_status = apply_scaling_from_short_to_byte_for_stdv_variable($
                         r_slope_standard_deviation_sst,$
                         r_stdv_sst4,$
                         o_byte_variable_array,$
                         o_byte_scale_factor,$
                         o_byte_add_offset);
if (debug_mode) then begin
print, 'Content of original short variable from NetCDF file:'
print, '          r_slope_standard_deviation_sst = ', r_slope_standard_deviation_sst;
print, '          r_intercept_standard_deviation_sst = ', r_intercept_standard_deviation_sst;   
print, 'ORIGINAL  : r_stdv_sst4[0,0]           = ', r_stdv_sst4[0,0];
print, 'CALCULATED: r_stdv_sst4[0,0]*r_slope_standard_deviation_sst + r_intercept_standard_deviation_sst= ', r_stdv_sst4[0,0] * r_slope_standard_deviation_sst + r_intercept_standard_deviation_sst;
print, ''
print, 'Content of scaled byte variable to be written to NetCDF file:'
print, '          o_byte_scale_factor              = ', o_byte_scale_factor;
print, '          o_byte_add_offset                = ', o_byte_add_offset;
print, 'ORIGINAL  o_byte_variable_array[0,0]) = ', o_byte_variable_array[0,0]
print, 'CALCULATED:o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset     = ', o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset;
endif

status = write_modis_data_variable(i_out_filename,$
             o_byte_variable_array,$
             i_dataset_name,$
             i_long_name,$
             i_units,$
             o_byte_scale_factor,o_byte_add_offset,$
             r_fill_value,r_data_type,$
             i_valid_min,i_valid_max,i_coordinates,i_source,i_comment);
endelse
endif; end if (ok_to_write_stdv_sst4_flag)

; ---------- Close up shop ---------- 

return, r_status
end
