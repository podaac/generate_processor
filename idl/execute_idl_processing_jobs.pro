;  Copyright 2010, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id$
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM 

FUNCTION execute_idl_processing_jobs, $
    i_processing_jobs_array, $
    i_use_cluster_flag, $
    i_optional_arg

; Program receives a list of IDL jobs as strings.  If TaskDL is available, it will send the jobs
; to the program farm_idl_jobs_to_taskdl. If not, it will use the EXECUTE command on each job.

;
; Assumptions:
;
;   1. The IDL jobs actually runs.
;   2. The IDL jobs are standalone programs.
;   3. The number of jobs is the size of the job array.
;   4. The optional_arg is for the MODIS L2P to pass in the product type {MODIS_A, MODIS_T, MODIS_A_REFINED, MODIS_T_REFINED}
;
;------------------------------------------------------------------------------------------------

;
; Load cluster management constants.
;

@cluster_management.cfg

;
; Local variables.
;

over_all_status = SUCCESS;

;-------------------------------------------------------------------------------------------------------------------------------------
; This is the big SWITCH.  Set variable PROCESSING_SWITCH to the appropriate string to either use the new idl_multi_processes_executor
; or continue to use the TaskDL (setting PROCESSING_SWITCH to 'CONTINUE_TO_USE_TASKDL')
;-------------------------------------------------------------------------------------------------------------------------------------

PROCESSING_SWITCH = 'USE_NEW_IDL_MULTI_PROCESSES_EXECUTOR';
;PROCESSING_SWITCH = 'CONTINUE_TO_USE_TASKDL';

if (2 EQ 2) then begin
if ((PROCESSING_SWITCH EQ 'USE_NEW_IDL_MULTI_PROCESSES_EXECUTOR') OR (N_ELEMENTS(i_use_cluster_flag) GT 0 )) then begin

    if (N_ELEMENTS(i_use_cluster_flag) GT 0 ) then begin
        print, 'execute_idl_processing_jobs.pro - INFO: i_use_cluster_flag = ' + i_use_cluster_flag;
    endif
;exit;
    over_all_status = idl_multi_processes_executor(i_processing_jobs_array,i_use_cluster_flag);

    return, over_all_status;
endif
endif

; 
; Get the name of the machine.  TaskDL is only available on the head node seaworld.jpl.nasa.gov,
; which is defined in cluster_management.cfg file.
;

print, "execute_idl_processing_jobs.pro - INFO: start_time = " + SYSTIME(/UTC); 
;print, "execute_idl_processing_jobs:checking for host name";
SPAWN, "printenv | grep HOST= | grep -v REMOTE", spawn_result;
num_lines = SIZE(spawn_result,/N_ELEMENTS);

; Split the line using = sign.
;print, "execute_idl_processing_jobs:num_lines = ", num_lines;
;print, "execute_idl_processing_jobs:splitting spawn_result";
splitted_array = STRSPLIT(spawn_result[num_lines-1],"=",/EXTRACT);
my_host = splitted_array[1];  The host name is the 2nd token.

;my_host = 'some_crazy_host';

; For now, set to MAKE_USE_CLUSTER_IF_AVAILABLE if user has not pass in the parameter.

if (N_ELEMENTS(i_use_cluster_flag) EQ 0) then begin
    i_use_cluster_flag = 'MAKE_USE_CLUSTER_IF_AVAILABLE';
    print, 'execute_idl_processing_jobs.pro - INFO: Reset i_use_cluster_flag to ', i_use_cluster_flag; 
endif

;print, 'i_use_cluster_flag = [',i_use_cluster_flag,']';

if ((STRPOS(my_host,CLUSTER_HEAD_NODE_NAME) GE 0) && $
    (i_use_cluster_flag EQ 'MAKE_USE_CLUSTER_IF_AVAILABLE')) then begin
    ;
    ; Farm the jobs out to TaskDL if the host name is the same as defined in configuration
    ; cluster_management.cfg file.
    ;

    over_all_status = farm_idl_jobs_to_taskdl(i_processing_jobs_array, i_optional_arg);

endif else begin

    num_jobs = SIZE(i_processing_jobs_array,/N_ELEMENTS);

;print, 'execute_idl_processing_jobs: num_jobs = ', num_jobs

    ;
    ; Process each job until exhausted the job array or until an error occurred.
    ;

    run_status = 1;
    job_number_index = 0;
    
    while ((job_number_index LT num_jobs) AND (run_status EQ 1)) do begin

        ;
        ; Use the EXECUTE program to execute the IDL jobs.  Variable run_status is set to 1 if
        ; the execution was successful, 0 if otherwise.
        ;

        ;print, 'execute_idl_processing_jobs: job_number_index = ', job_number_index, ' num_jobs = ', num_jobs 
        ; Get the token on the left of ":" if it exists.  It's OK if the ":" is not there, the
        ; STRSPLIT() function will return only one element.

        splitted_array = STRSPLIT(i_processing_jobs_array[job_number_index],":",/EXTRACT);  

        ; Run it.

        run_status = EXECUTE(splitted_array[0]);

        ; Make sure the status is good.  If not the loop ends.

        if (run_status NE 1) then begin
           print, "execute_idl_processing_jobs.pro - ERROR: The below procedure failed:";
           print, "execute_idl_processing_jobs.pro - INFO: " + i_processing_jobs_array[job_number_index];
           print, "execute_idl_processing_jobs.pro - INFO: job_number_index = ", job_number_index
           print, "execute_idl_processing_jobs.pro - INFO: num_jobs = ", num_jobs 

          l_status = error_log_writer($
             'execute_idl_processing_jobs',$
             'The below procedure failed:' + i_processing_jobs_array[job_number_index]);

        endif

        ; Make sure we skip to the next job.

        job_number_index = job_number_index+ 1; 

    endwhile
endelse

print, "execute_idl_processing_jobs.pro - INFO: end_time = " + SYSTIME(/UTC); 
return, over_all_status;

end
