;  Copyright 2014, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id$
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

FUNCTION is_value_an_array, i_value, o_separator_token
   ; Function tries to determine if a value is a scalar or an array.
   ; As convention, an array is:
   ;    1. has ARRAY as the first 5 characters,
   ;    2. multiple tokens separated by spaces or comma:
   ;
   ; If the value is an array, the value of o_separator_token will contain the value.

   o_value_is_array_flag = 0;
   o_separator_token = '';

   if (STRCMP(i_value,"ARRAY",5)) then begin
       o_value_is_array_flag = 1;
       pos_of_space = STRPOS(i_value,' ');
       if (pos_of_space GE 0) then o_separator_token = ' ';
       pos_of_comma = STRPOS(i_value,',');
       if (pos_of_comma GE 0) then o_separator_token = ',';
   endif else begin
       ; If the ARRAY is not at beginning, we look for either a space or a comm.
       pos_of_space = STRPOS(i_value,' ');
       if (pos_of_space GE 0) then begin 
            o_separator_token = ' ';
            o_value_is_array_flag = 1;
       endif else begin
           pos_of_comma = STRPOS(i_value,',');
           if (pos_of_comma GE 0) then begin
               o_separator_token = ',';
               o_value_is_array_flag = 1;
           endif
       endelse
   end
   
return, o_value_is_array_flag;
END

FUNCTION find_netcdf_variable_attribute_info,$
         i_variable_name,$
         i_attributes_array,$
         o_attribute_value

; Function returns a variable attribute given a variable name and the array containing a list of attributes.
; If i_variable_name is not defined or empty string, function will return an empty string.
;
; Assumptions:
;
;   1. TBD
;

;------------------------------------------------------------------------------------------------

; Load constants.

@data_const_config.cfg

; Define local variables.

o_read_status = SUCCESS;
debug_flag = 0;

; Get the DEBUG_MODE if it is set.

debug_module = 'find_netcdf_variable_attribute_info:';
if (STRUPCASE(GETENV('GHRSST_MODIS_L2_COMBINER_DEBUG_MODE')) EQ 'TRUE') then begin
    debug_flag = 1;
endif

;print, 'find_netcdf_variable_attribute_info: INFO, i_variable_name = ',i_variable_name 

; Set default return value.
o_attribute_value = ''

array_index = 0;
found_variable_name_flag = 0;

while (array_index LT  N_ELEMENTS(i_attributes_array)) AND (found_variable_name_flag EQ 0) do begin
;    print, 'find_netcdf_variable_attribute_info:Inspecting [', i_attributes_array[array_index], ']';
    splitted_tokens = STRSPLIT(i_attributes_array[array_index],'|', /EXTRACT);
    if (debug_flag) then begin
        print, debug_module + 'array_index ', array_index, 'i_attributes_array ', i_attributes_array
    endif
    ; The format is:
    ;      long_name|BYTE|Sea Surface Temperature
    ;      scale_factor|FLOAT|0.00500000 
;    print, 'find_netcdf_variable_attribute_info:    splitted_tokens[0] [', splitted_tokens[0] , ']';
;    print, 'find_netcdf_variable_attribute_info:    splitted_tokens[1] [', splitted_tokens[1] , ']';
;    print, 'find_netcdf_variable_attribute_info:    splitted_tokens[2] [', splitted_tokens[2] , ']';
;    print, 'i_variable_name    [', i_variable_name , ']';
    if (i_variable_name EQ splitted_tokens[0]) then begin
        ;o_attribute_value = STRING(splitted_tokens[2]);
        ; Get the type of the attribute before setting it.
;print, 'splitted_tokens[1] = ', splitted_tokens[1];
;stop;
        if (splitted_tokens[1] EQ "BYTE") then begin
            if ((splitted_tokens[0] EQ 'long_name') OR ( splitted_tokens[0] EQ 'units')) then begin 
                o_attribute_value = STRING(splitted_tokens[2]);
            endif else begin
                ; Check to see if the last characater ends with 'b' as in:
                ;
                ;    _FillValue|BYTE|-1b
                ;    valid_min|BYTE|0b
                ;    valid_max|BYTE|5b
 
                ; If it does, remove it before converting to BYTE function.
                string_length              = STRLEN(splitted_tokens[2])
                characters_before_letter_b = STRMID(splitted_tokens[2],0,string_length-1)
                last_character             = STRMID(splitted_tokens[2],string_length-1,1);

                if (debug_flag) then begin
                    print, 'find_netcdf_variable_attribute_info: i_variable_name   [', i_variable_name, ']';
                    print, 'find_netcdf_variable_attribute_info: third_column      [', splitted_tokens[2], ']';
                    print, 'find_netcdf_variable_attribute_info: string_length     [', string_length, ']';
                    print, 'find_netcdf_variable_attribute_info: characters_before_letter_b [', characters_before_letter_b , ']';
                    print, 'find_netcdf_variable_attribute_info: last_character             [', last_character, ']';
                endif

                if (last_character EQ 'b') then begin
                    o_attribute_value = BYTE(FIX(splitted_tokens[2]));   The FIX() changes -1b to INT -1 and BYTE() changes -1 to 255
                endif else begin
                    o_attribute_value = BYTE(splitted_tokens[2]);
                endelse
            endelse
        endif
        if (splitted_tokens[1] EQ "FLOAT") then begin
            o_attribute_value = FLOAT(splitted_tokens[2]);
        endif
        if (splitted_tokens[1] EQ "LONG") then begin

            ; Check to see if the attribute is an ARRAY: ARRAY 32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
            ; If it is, we have to break up all the tokens and store them into an array.
            last_token = splitted_tokens[2];
            if (STRCMP(last_token,"ARRAY",5)) then begin
                tokens_array = STRSPLIT(last_token,/EXTRACT);
                num_of_values = tokens_array[1];
                value_index = 0;
                o_attribute_value = LONARR(num_of_values);
                ELEMENTS_OFFSET = 2;  We skip the first 2 tokens "ARRAY 32" to get to "1"
                while (value_index LT num_of_values) do begin
                    o_attribute_value[value_index] = tokens_array[ELEMENTS_OFFSET + value_index];
                    value_index = value_index + 1;
                end
            endif else begin
                o_attribute_value = LONG(splitted_tokens[2]);
            endelse
        endif

        ; In IDL, an INT and SHORT are the same thing.  We can deal with both in this next if statement.
        if ((splitted_tokens[1] EQ "INT") OR (splitted_tokens[1] EQ "SHORT")) then begin
            ; Check to see if the attribute is an ARRAY: ARRAY 32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
            ; If it is, we have to break up all the tokens and store them into an array.
            last_token = splitted_tokens[2];
            o_value_is_array_flag = is_value_an_array(last_token, o_separator_token);
            ; If the value is an array due to containing "ARRAY" we know the separator token is a space.
            if (o_value_is_array_flag AND STRCMP(last_token,"ARRAY",5)) then begin
                tokens_array = STRSPLIT(last_token,/EXTRACT)
                num_of_values = tokens_array[1];
                value_index = 0;
                o_attribute_value = INTARR(num_of_values);
                ELEMENTS_OFFSET = 2;  We skip the first 2 tokens "ARRAY 32" to get to "1"
                while (value_index LT num_of_values) do begin
                    o_attribute_value[value_index] = tokens_array[ELEMENTS_OFFSET + value_index];
                    value_index = value_index + 1; 
                end
            endif
            ; If the value is an array due to containing either spaces or comma, we parse differently.
            if (o_value_is_array_flag AND (o_separator_token EQ ' ' OR o_separator_token EQ ',')) then begin
                tokens_array = STRSPLIT(last_token,o_separator_token,/EXTRACT,COUNT=num_of_values);
                value_index = 0;
                o_attribute_value = INTARR(num_of_values);
                while (value_index LT num_of_values) do begin
                    o_attribute_value[value_index] = tokens_array[value_index];
                    value_index = value_index + 1; 
                end
            endif 

            if (~o_value_is_array_flag) then begin
                o_attribute_value = FIX(splitted_tokens[2]);
            endif
        endif
        if (splitted_tokens[1] EQ "STRING") then begin
            if (N_ELEMENTS(splitted_tokens) LE 2) then begin
                o_attribute_value = '';
            endif else begin
                o_attribute_value = STRING(splitted_tokens[2]);
            endelse
        endif
    endif
    array_index++;
endwhile
if (debug_flag) then begin
    print, 'find_netcdf_variable_attribute_info:    i_variable_name   [', i_variable_name, ']';
    print, 'find_netcdf_variable_attribute_info:    o_attribute_value [', o_attribute_value , ']';
    print, 'find_netcdf_variable_attribute_info:    SIZE(o_attribute_value,/TNAME) [', SIZE(o_attribute_value,/TNAME) , ']';
endif

;if (i_variable_name EQ 'flag_masks') then stop;

; ---------- Close up shop ---------- 
return, o_read_status;
end
