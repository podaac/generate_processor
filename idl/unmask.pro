;  Copyright 2006, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id: unmask.pro,v 1.2 2006/10/24 23:57:10 qchau Exp $
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CVS

;+NAME/ONE LINE DESCRIPTION OF ROUTINE:
;    UNMASK converts a scalar or array of bit masks into a binary array.

;
;------------------------------------------------------------
; Function UNMASK
;
; Written By:  BA Franz, Applied Research Corp, 1991
; Modified by: Qui Chau for
;                1) Inclusion into the GHRSST MODIS L2P Processing
;                2) Coding standard
;
; IDL function to convert a scalar or array of bit masks into
; an array of 0's and 1's.
;
; Inputs:
;   i_mask   - scalar or array of mask elements (Byte, Word, Long)
;
; Output:
;   r_mask_array - bytarr(nbits,nelements) where nbits is the number of
;              bits in mask and nelements is the number of mask
;              elements.  A value of 1 means the bit was set.  The
;              r_mask_array(0,0) is the zeroth bit of the first mask.
;
; Calling Sequence:
;
;   l_status = UNMASK(i_mask,r_mask_array)
;
;------------------------------------------------------------
FUNCTION unmask,i_mask, $
                r_mask_array

; Load constants.

@modis_data_config.cfg

; Define local variables.

r_status = SUCCESS;

;
; Get integer type to determine number of bits in mask.
;

mask_size_array   = size(i_mask)

; Some convention:
;
; The number of dimensions is the first element.
; The 2nd element is the size of each dimension.
; The last two elements are the type code and the number of elements in i_mask array.
;

num_dimensions   = mask_size_array(0)      ; The number of dimensions is the first element.
typ = mask_size_array(num_dimensions+1)    ; The type code is one after the num of dimensions.

case typ of
    1 : nbits =  8
    2 : nbits = 16
    3 : nbits = 32
    else : begin
        print, 'unmask: FATAL, Invalid data type.  Must be BYTE, WORD, or LONG.'
        print, 'unmask: typ = ', typ;
        print, 'unmask: num_dimensions = ', num_dimensions;
        r_status = FAILURE;
        ; Must return immediately.
        return, r_status;
    endelse
endcase

;
; Determine number of mask elements and set-up output array
;

npts  = n_elements(i_mask)        ; Number of mask elements
tmask = i_mask                    ; Temporary mask
r_mask_array = bytarr(nbits,npts) ; Output array
shft_array = intarr(npts) - 1     ; Array of -1's for shift control

;print, 'unmask:';
;
;help, npts
;help, tmask
;help, r_mask_array
;help, shft_array

;
; Repeat for nbits.
; Check to see if last bit is set.  If it is, then set the output
; array element to 1.  Shift the array of mask elements right 1 bit.
;

for i = 0,nbits-1 do begin
    select = where(abs(tmask mod 2) eq 1)
    if (select(0) ne -1) then r_mask_array(i,select) = 1
    tmask = ishft(tmask,shft_array)
endfor

return, r_status
end

