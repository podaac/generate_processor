#
#  OCEANIDS Input/Output Locking mechanism
#
#  COPYRIGHT 2004, CALIFORNIA INSTITUTE OF TECHNOLOGY, ALL RIGHTS RESERVED
#
#  Author: Andrew Bingham, andrew.bingham@jpl.nasa.gov, Alex Cervantes alex@seastar.jpl.nasa.gov
#
#  Methods to exclusively lock a file during writing, appending and reading.
#  Note, exclusive lock can not be optained in read mode - the solution is
#  to open in read-append mode.  Use this mode for read-write also (saver).
#  once the file is opened use content and print methods to access data.  Don't
#  forget to close (release) the file after using.
#
#  When file is opened/locked status is set to 1 if successful, otherwise
#  it is set to undef.  Comment is set if there's a failure or the lock is
#  temporarily blocked.
#
#  Modified slightly by Qui Chau for inclusion into CM.
#
# $Id: OLock.pm,v 1.2 2007/08/16 16:25:10 qchau Exp $
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CVS

package OLock;

use strict;
use FileHandle;
use Fcntl qw(:DEFAULT :flock);


#Module Description: Constructor.
#Arguments: log file name
#1. Optional parameters (to be passed in a hash like fashion,
#2. using key and value pairs are:
#3.  file - name of lock file.
##
sub new {
    my $class = shift;
    my $file = shift;

    my $self = {};
    bless ($self, $class);

    $self->{file} = $file if ( defined($file) );
    # should do something if file is not set, or maybe later??

    # parse any key-value pairs
    if (@_) {
        my %extra = @_;
        @$self{keys %extra} = values %extra;
    }

    #automatically semlocks the file, remember you have to close it by hand
    $self->semlock;

    return $self;
}


#Module Description: Opons a file for reading, writing, or appending
#Arguments: mode to open the file
#1. Switch statement determining which method to open the file
##
sub fileopen{
    my $self = shift;
    my $filemode = shift;

    #set the file mode else complain invalid file mode (valid file modes are (read, write, append)
    my $modeaction = "";
    my $modeword = "";
    if($filemode eq "a") {
            $modeaction = ">>";
            $modeword = "append"
    }
    elsif($filemode eq "r") {
            $modeaction = "<";
            $modeword = "read"
    }
    elsif($filemode eq "w") {
            $modeaction = ">";
            $modeword = "write"
    }
    else {
    $self->{status} = undef;
    $self->{comment} = "Invalid File Mode $modeword $self->{file}: $!";
            return 0;
    }

    $self->{fh} = new FileHandle "$modeaction$self->{file}";
    if (!defined($self->{fh})) {
        $self->{status} = undef;
        $self->{comment} = "Can't open for $modeword $self->{file}: $!";
        return 0;
    }

    return 1;
}

#Module Description: close the filehandle which was opened for reading, writing, or appending
##
sub fileclose {
    my $self = shift;

        #close the registry filehandle
    undef $self->{fh};
}

#Module Description: creates a semaphore lock on the current file
#1. Create a semaphore file for the file which is going to be locked
#2. Place pid information to track which process performed the semlock
#2. Flock the semaphore file until it is ready to be given up
##semaphore implementation
sub semlock{
    my $self = shift;

    $self->{status} = 1;        #set good status
    $self->{comment} = undef;   #no comment

    #open the semaphore file
    my $SEMAPHORE = "$self->{file}.lock";
    $self->{semfh} = new FileHandle ">$SEMAPHORE"; #open semaphore in write mode

    #dump error on bad semaphore error
    if (!defined($self->{semfh})) {
        $self->{status} = ();
        $self->{comment} = "Can't open for SEMAPHORE $self->{file}.lock: $!";
                return 0;
    }

    #write to semaphore file what time it was opened
    #the if statement is used to allow web cgi scripts to semlock files
    $self->printsem("SEMAPHORE OPENED with PID of $$\n") if (defined($$));

        
    #flock the semaphore file
    unless (flock($self->{semfh}, LOCK_EX|LOCK_NB)) {
        $self->{comment} = "Can't immediately get SEMAPHORE (append) on $self->{file}.lock ($!), blocking ...";
 unless (flock($self->{semfh}, LOCK_EX)) {
            $self->{status} = ();
            $self->{comment} .= "\nCan't get SEMAPHORE (append) on $self->{file}.lock: $!";
                    return 0;
        }
    }
}   
    
    
#unlock the semaphore file
sub semunlock {
    my $self = shift;

    #the if statement is used to allow web cgi scripts to semlock files
    $self->printsem("SEMAPHORE CLOSED with PID of $$\n") if(defined($$));
    flock($self->{semfh}, LOCK_UN);
}

    
# return the contents of the file
sub content {
    my $self = shift;

    my $fh = $self->{fh};
    return  <$fh>;
}
    
# return a reference to the contents of the file
sub content_ref {
    my $self = shift;
 
    my $fh = $self->{fh};
    my @content =  <$fh>;
    return \@content;
}


# print a scalar to file
sub printsem { 
    my ($self, $data) = @_;

    my $semfh = $self->{semfh}; 

    print $semfh $data;
}
    
# print a scalar to file 
sub print {
    my ($self, $data) = @_;
    
    my $fh = $self->{fh}; 
    print $fh $data;
}
    
# print an array to file
sub printa {
    my ($self, $array_ref) = @_; 
    
    my $fh = $self->{fh};
    print $fh @{ $array_ref };
}

# return file handle
sub fh {
    my $self = shift;

    return $self->{fh};
}

sub semfh {
    my $self = shift;

    return $self->{semfh};
}

# return the comment value
sub comment {
    my $self = shift;

    return $self->{comment};
}

# return the status value
sub status {
    my $self = shift;

    return $self->{status};
}

1;

__END__

