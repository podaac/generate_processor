#!/usr/local/bin/perl

#  Copyright 2008, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# Subroutine to filter on Night data sets: exclude data set if two files have the same
# start time. 
#
# Assumption(s):
#
#   1. TBD 
#
#------------------------------------------------------------------------------------------------

use File::Basename;  # Use in parsing the full file name.

do "$GHRSST_PERL_LIB_DIRECTORY/uncompress_one_modis_dataset.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/report_error_to_error_file_registry.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/email_ops_to_report_error.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/get_error_file_registry_filename.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/create_modis_processing_error_string.pl";

sub filter_for_night_datasets {


    # Returned status.  Value of 0 means ok, 1 means bad.

    my $o_status = 0;

    #
    # Get input.
    #

    my $ref_unfiltered_filelist = shift; 

    # 
    # Local variables.  The @$ on the Right Hand Side (RHS) dereference the reference.
    #

    my @l_unfiltered_filelist = @$ref_unfiltered_filelist;
    my $num_unfiltered_filenames = @l_unfiltered_filelist; 

    # Return variable(s):

    my @r_filtered_filelist = ();

    my $name_only = "";

    my $previous_full_name    = "DUMMY";  # Just the first part of the name.
    my $previous_partial_name = "DUMMY";  # Just the first part of the name.
    my $current_partial_name  = "DUMMY";
    my $saved_count_index = 0;
    my $num_duplicate = 0;

#print ">>> num_unfiltered_filenames $num_unfiltered_filenames\n";
    for ($count = 0; $count < $num_unfiltered_filenames; $count++) {
#print "      count = [$count]\n";
        chomp($l_unfiltered_filelist[$count]);  # Remove the carriage return.

        # If there is only one element, we save it right away.
        if ($num_unfiltered_filenames == 1) {
            $r_filtered_filelist[0] = $l_unfiltered_filelist[0];
            next;
        }

        # Parse the name as in
        #
        #     A2008099021500.L2_LAC_GSSTD.bz2
        #
        # for the partial name.

        ($name_only,$directory_path) = fileparse($l_unfiltered_filelist[$count]);

        # Parse for the start time.

        my @splitted_array = split(/\./,$name_only);
        $current_partial_name = $splitted_array[0];

        # Compare the current_partial_name with previous_partial_name.
        # If the same then we take the current name.  Else, we take the previous name.

        if ($current_partial_name eq $previous_partial_name) {
            $num_duplicate += 1;
            if (($count + 1) != $num_unfiltered_filenames) {
#print ">> NAME SAME NOT LAST: current_partial_name is same with previous_partial_name = [$current_partial_name] [$previous_partial_name]\n";

                $previous_partial_name = $current_partial_name;
                $previous_full_name    = $l_unfiltered_filelist[$count]; 

            } else {
                # The previous and the current names are the same, we save the current one
#print ">> NAME SAME INDEED LAST: current_partial_name is same with previous_partial_name = [$current_partial_name] [$previous_partial_name]\n";
                $r_filtered_filelist[$saved_count_index] = $l_unfiltered_filelist[$count];
                $saved_count_index += 1;  # Keep track of how many names saved.
            }
        } else {

            # The first case is treated differently.

            if ($count != 0) {
                
                # If the name is the last and different from the previous, we save both. 
                if (($count + 1) == $num_unfiltered_filenames) {

                    # Save previous name.
                    $r_filtered_filelist[$saved_count_index] = $previous_full_name;
                    $saved_count_index += 1;  # Keep track of how many names saved.
                    # Save current name.
                    $r_filtered_filelist[$saved_count_index] = $l_unfiltered_filelist[$count];
                    $saved_count_index += 1;  # Keep track of how many names saved.
#print ">> NAME DIFFERENT INDEED LAST ONE SAVE PREVIOUS ONE AND CURRENT ONE [$previous_full_name] [$l_unfiltered_filelist[$count]]\n";
                } else {
                    # The name is not the last name of the list, save it.
                    $r_filtered_filelist[$saved_count_index] = $previous_full_name;
                    $saved_count_index += 1;  # Keep track of how many names saved.
#print ">> NAME DIFFERENT NOT LAST ONE SAVE PREVIOUS ONE [$previous_full_name]\n";

                    # Remember for next loop.
                    $previous_partial_name = $current_partial_name;
                    $previous_full_name    = $l_unfiltered_filelist[$count]; 
                }

            } else {
                # First case, we don't do anything.  Just save the partial name
                # and full name.
                $previous_partial_name = $current_partial_name;
                $previous_full_name    = $l_unfiltered_filelist[$count]; 
#print ">> NAME FIRST SAVE FOR NEXT [$previous_partial_name] [$previous_full_name]\n";
            }
        }
    }

    my $num_of_saved_list = @r_filtered_filelist;
#    print "filter_for_night_datasets: num_duplicate = $num_duplicate\n";
#    print "filter_for_night_datasets: num_of_saved_list = $num_of_saved_list\n";
#    print "filter_for_night_datasets: num_unfiltered_filenames $num_unfiltered_filenames\n";

    # ---------- Close up shop ----------
    return (@r_filtered_filelist);

} # end sub filter_for_night_datasets
