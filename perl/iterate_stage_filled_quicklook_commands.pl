#!/usr/local/bin/perl

#  Copyright 2008, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# Subroutine stage the Filled Quicklook MODIS datasets for processing by attempting to perform the copying 5 times
# to the staging area.
#
# Assumption:
#
#   1) The file to be staged exist.
#   2) TBD. 
#
#------------------------------------------------------------------------------------------------

use File::Basename;  # Use in parsing the full file name.

do "$GHRSST_PERL_LIB_DIRECTORY/uncompress_one_modis_dataset.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/error_log_writer_helper_pro_via_perl.pl";

sub iterate_stage_filled_quicklook_commands {


    # Returned status.  Value of 0 means ok, 1 means bad.

    my $o_status = 0;

    #
    # Get input.
    #

    my $i_scratch_area                 = shift;
    my $i_processing_type              = shift;
    my $i_uncompress_flag              = shift;
    my $i_uncompressed_data_filename   = shift;
    my $i_datasource                   = shift;

    # For every file in the list, perform the copying to the stage area.

    my $name_only = "";
    my $directory_path = "";
    my $destination_name = "";

    my $compressed_file_extension =".bz2";
    my @splitted_array = (); 
    my $the_year    = "";
    my $day_of_year = "";
    my $new_source_name = "";

    my $data_store       = $ENV{GHRSST_PUBLIC_STORE_DATA_L2P};
    my $institution_name = $ENV{RDAC_INSTITUTION_NAME};

    my $MAX_LOOP             = 5;
    my $copied_success       = 0;
    my $uncompressed_success = 0;
    my $attempt_index        = 1;
    my $attempts_exhausted   = 0;

    # Start out assuming we are successful with this subroutine.
    $o_status = 0;

    chomp($i_uncompressed_data_filename);  # Remove the carriage return.

    # Parse the name.
    ($name_only,$directory_path) = fileparse($i_uncompressed_data_filename);

    # Build the destination name to include the sub-directories:
    #
    # as in /store/ghrsst/public/data/L2P/MODIS_A/JPL/year/day_of_year/
    #    20071105-MODIS_A-JPL-L2P-A2007309011000.L2_LAC_GHRSST-v01.nc.bz2

    # Split the $name_only by '-'
    @splitted_array = split(/-/,$name_only);

    # The year is the 5th element (element 4), character 2 through 5 (index 1 through 4). 
    $the_year    = substr($splitted_array[4],1,4);
    $day_of_year = substr($splitted_array[4],5,3);

    $new_source_name = "$data_store/$i_datasource/$institution_name/$the_year/$day_of_year/$name_only" . "$compressed_file_extension";

    # Form the destination name so we can check to see if it exists already.
    $destination_name = $i_scratch_area . "/" . $name_only . $compressed_file_extension;

    # Repeat 5 times or until able to copy and uncompressed.
    do {

#print "--------------------------------------------------------------------------------\n";
#print "iterate_stage_filled_quicklook_commands:INFO, attempt_index = $attempt_index\n";
        #
        # Only copy the file if it does not exist already at the destination.
        #

#print "  cp $new_source_name $i_scratch_area/\n";
#print "  destination_name = $destination_name\n";

        # Before copying, check to see if the file exists.  If not, we exit this loop.
        if (!(-e $new_source_name)) {
            print "iterate_stage_filled_quicklook_commands:INFO, File $new_source_name does not exist.\n";
            $attempts_exhausted = 1;
        } else {

          # File does exist at destination already, we will not copy it. 
        if (-e $destination_name) {
print "iterate_stage_filled_quicklook_commands:INFO, File $destination_name exist.  Will not be copied.\n";

            $copied_success = 1; # Eventhough this code did not copy the file, it is found so we considered it copied. 

            # Uncompress the file also if flag is set.
            if (lc($i_uncompress_flag) eq 'yes') {
print "  INFO, Performing uncompressing on $destination_name\n";

                my $l_status = uncompress_one_modis_dataset($destination_name);
                # If the file was copied and uncompressed, we keep track of how many.
                if ($l_status == 0) {
                    $uncompressed_success = 1;
                    $attempts_exhausted = 1;
                }
            } else {
                print "iterate_stage_filled_quicklook_commands:INFO, i_uncompress_flag = [$i_uncompress_flag]\n";
                $attempts_exhausted = 1;
            }
        } else {
            # File does not exist at destination, we will attempt to copy it. 
            system("cp $new_source_name $i_scratch_area/");
print "  INFO, Copying $new_source_name to $destination_name\n";

            #
            # Check for errors from the cp command.
            #
            my $l_proceed_to_uncompress_flag = 0;

            if ($? == -1) {
                print "iterate_stage_filled_quicklook_commands:ERROR, system cp $new_source_name $i_scratch_area/ failed to execute: $?\n";
                $o_status = 1;
            } elsif ($? == 256){
                print "iterate_stage_filled_quicklook_commands:ERROR, Cannot find file  $new_source_name.\n";
                print "iterate_stage_filled_quicklook_commands:attempt_index $attempt_index failed\n";
                $o_status = 1;
            } elsif ($? == 0){
                $l_proceed_to_uncompress_flag = 1;  # We set this so the file will get uncompress later. 
                $copied_success               = 1;
            } else {
                print "iterate_stage_filled_quicklook_commands:ERROR, system cp $new_source_name $i_scratch_area/ executed with: $?\n";
                $o_status = 1;
            }

            if ($l_proceed_to_uncompress_flag == 1) {
                # Uncompress the file also if flag is set.
                if (lc($i_uncompress_flag) eq 'yes') {
print "  INFO, Performing uncompressing on $destination_name\n";

                   my $l_status = uncompress_one_modis_dataset($destination_name);
                   # If the file was copied and uncompressed, we keep track of how many.
                   if ($l_status == 0) {
                      $uncompressed_success = 1;
                      $attempts_exhausted = 1;
                   }
                } else {
                    print "iterate_stage_filled_quicklook_commands:INFO, i_uncompress_flag = [$i_uncompress_flag]\n";
                    $attempts_exhausted = 1;
                }
            } # end if ($l_proceed_to_uncompress_flag == 1)
        } #  end if (!(-e $destination_name))
        }

        $attempt_index += 1; 

    } until (($attempt_index > $MAX_LOOP) || ($attempts_exhausted == 1));
print "--------------------------------------------------------------------------------\n";

    # Depends on what happened above, we report it to error log file.

    if ($copied_success == 0) {

        #
        # Send an INFO message to the GHRSST Error Log Archive.
        #

# Commented out as it is often that the Filled Quicklook file is long removed
# from the public storage.  Writing to error log becomes unnecessary.

#        my $l_calle_name   = "stage_filled_quicklook_datasets_for_processing";
#        my $l_error_reason = "INFO:Cannot find file $new_source_name";
#
#        error_log_writer_helper_pro_via_perl(
#            $l_calle_name,
#            $l_error_reason);

    } else {
        # Was able to copy the file, check to see if it was able to be compressed.

        if ($i_uncompress_flag eq "yes" && $uncompressed_success == 0) {

            #
            # Send an INFO message to the GHRSST Error Log Archive.
            #

            my $l_calle_name   = "stage_filled_quicklook_datasets_for_processing";
            my $l_error_reason = "INFO:File $new_source_name may be corrupted.";

            error_log_writer_helper_pro_via_perl(
                $l_calle_name,
                $l_error_reason);
        } else {
            print "iterate_stage_filled_quicklook_commands:INFO, i_uncompress_flag = [$i_uncompress_flag] and uncompressed_success = [$uncompressed_success]\n";
        }
    }

    # ---------- Close up shop ----------
    return ($o_status);

} # end sub iterate_stage_filled_quicklook_commands
