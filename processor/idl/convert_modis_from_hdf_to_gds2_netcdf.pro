;  Copyright 2015, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id$
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

FUNCTION convert_modis_from_hdf_to_gds2_netcdf,$
             i_filename,$
             i_out_filename,$
             i_start_time_array_element,$
             i_convert_to_kelvin,$
             i_processing_type,$
             o_day_or_night,$
             i_test_parameter 

; Function convert a MODIS file from HDF format to NetCDF in GDS2 format.  This function is similiar to convert_modis_from_hdf_to_netcdf() except for GDS2 output format
;
; Assumptions:
;
;   1. TBD.
;
; October, 2013: Added extra parameter i_test_parameter to allow testing of different fail scenarios.
;                The possible values are defined in the new test script convert_modis_from_hdf_to_gds2_netcdf_test.pro
;
;                      "BAD_INPUT_FILE";
;                      "MISSING_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_LONG_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_FLOAT_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_OUTPUT_FILE_CREATION";
;                      "BAD_START_TIME_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_END_TIME_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_SENSOR_NAME_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_START_NODE_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_END_NODE_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_DAY_OR_NIGHT_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_CNTL_PT_COLS_VARIABLE_READ";
;                      "BAD_CNTL_PT_ROWS_VARIABLE_READ";
;                      "BAD_LONGITUDE_VARIABLE_READ";
;                      "BAD_LONGITUDE_SCAN_LINES";
;                      "BAD_LATITUDE_VARIABLE_READ";
;                      "BAD_LATITUDE_SCAN_LINES";
;                      "BAD_SST_VARIABLE_READ";
;                      "BAD_SEA_SURFACE_TEMPERATURE_VARIABLE_WRITE";
;                      "BAD_SST_DTIME_VARIABLE_WRITE";
;                      "BAD_LAT_VARIABLE_WRITE";
;                      "BAD_LON_VARIABLE_WRITE";
;                      "BAD_TIME_VARIABLE_WRITE";

;------------------------------------------------------------------------------------------------

; Load constants.

@modis_data_config.cfg

; Define local variables.

r_status = SUCCESS;

; Define some output variable so if we return quickly, the variable will be defined.

o_day_or_night = 'Day';  Set default to 'Day'.  It will be set to whatever we fetch from the file.

; Set our test parameter based on what's being passed in,
TEST_PARAMETER = "";
if (N_ELEMENTS(i_test_parameter) NE 0) then begin
    TEST_PARAMETER = i_test_parameter;
endif

; Variables for reporting sigevents.

routine_name = "convert_modis_from_hdf_to_gds2_netcdf";
msg_type = "";
msg = ""
i_data = "";

; Get the DEBUG_MODE if it is set.

debug_module = 'convert_modis_from_hdf_to_gds2_netcdf:';
debug_mode = 0
if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_DEBUG_MODE')) EQ 'TRUE') then begin
    debug_mode = 1;
endif

; Memory related.

bytes_mem_start = MEMORY(/CURRENT);
;message = 'Current amount of dynamic memory used is ';
;sentence = debug_module + message + STRTRIM(bytes_mem_start,2)+' bytes.';
;print, sentence;

; Set this flag to allow this function to use TEMPORARY function to reset a variable to an undefined state.
; Setting the flag allows the memory to be send back to the HEAP.

clear_memory_flag = 1;

routine_start = SYSTIME(/SECONDS);

; Set flag to use the slow functions if requested.  This allow developer to switch between the slow and fast functions.
; The original functions are considered slow.  The fast function are newer.

run_slow_function = 0;  Default to not using the slow function.
if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_USE_SLOW_FUNCTION')) EQ 'TRUE') then begin
    run_slow_function = 1;
endif

; MODIS_L2P_ERROR_STEP 1. If the input file does not exist, ERROR sigevent thrown, returns.

; Return if file does not exist.

file_exist = FILE_TEST(i_filename);

if (TEST_PARAMETER EQ "BAD_INPUT_FILE") then begin
    file_exist = 0;
endif

if (file_exist EQ 0) then begin
    r_status = FILE_NOT_FOUND_STATUS;
    msg_type = "error";
    msg = 'Input file not found ' + i_filename; 
    print, debug_module + msg;
    l_status = error_log_writer(routine_name,msg);

    return, r_status;
endif

; Get just the file name without the directory.

splitted_string = strsplit(i_filename, "/", /REGEX, /EXTRACT);
num_substrings = SIZE(splitted_string,/N_ELEMENTS);
in_filename_only = splitted_string[num_substrings-1];

r_status = read_long_variables_from_hdf_file($
               i_filename,$
               i_test_parameter,$
               long_attributes_values);

if (r_status NE SUCCESS) then begin 
    return, r_status;
endif

;
; Save most used global attributes.
;

num_lons = long_attributes_values[Number_of_Scan_Lines_index];
num_lats = long_attributes_values[Pixels_per_Scan_Line_index];

r_status = read_float_variables_from_hdf_file($
               i_filename,$
               float_attributes_values,$
               i_test_parameter);

if (r_status NE SUCCESS) then begin
    return, r_status;
endif

;
; Read the start time and end time as strings.  Must convert them to seconds.
;
attribute_name = 'Start Time';
r_status = read_hdf_global_attribute(i_filename,attribute_name,r_start_time);

if (TEST_PARAMETER EQ "BAD_START_TIME_GLOBAL_ATTRIBUTE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg_type = 'error';
    msg = 'Cannot read string global attribute ' + attribute_name + ' from file ' + i_filename;
    print, debug_module + msg;
    l_status = error_log_writer(routine_name,msg);
    ; Must return immediately.
    return, r_status
endif

; Make sure the time field is valid.

o_time_field_valid_flag = validate_time_field($
                              attribute_name,$
                              r_start_time,o_timestamp_string);

if (o_time_field_valid_flag NE SUCCESS) then begin
    status = FAILURE;
    msg_type = 'error';
    msg = 'Attribute ' + attribute_name + ' from file ' + i_filename + ' is not a valid time field.';
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    return, status;
endif

; At this point, we are confident that the value in r_start_time is valid.

attribute_name = 'End Time';
r_status = read_hdf_global_attribute(i_filename,attribute_name,r_end_time);

if (TEST_PARAMETER EQ "BAD_END_TIME_GLOBAL_ATTRIBUTE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    status = FAILURE;
    msg_type = "error";
    msg = "Cannot read string global attribute " + attribute_name + " from file " + i_filename;
    print, msg;
    l_status = error_log_writer(routine_name,msg);
    ; Must return immediately.
    return, status
endif

; Make sure the time field is valid.

o_time_field_valid_flag = validate_time_field($
                              attribute_name,$
                              r_end_time,o_timestamp_string);

if (o_time_field_valid_flag NE SUCCESS) then begin
    status = FAILURE;
    msg_type = 'error';
    msg = 'Attribute ' + attribute_name + ' from file ' + i_filename + ' is not a valid time field.';
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    return, status;
endif

; At this point, we are confident that the value in r_end_time is valid.

start_seconds = long_attributes_values[Start_Millisec_index] / 1000.0;
end_seconds   = long_attributes_values[End_Millisec_index] / 1000.0;

if (debug_mode) then begin
    print, debug_module + 'start_seconds = ', start_seconds;
    print, debug_module + 'end_seconds   = ', end_seconds;
endif

; Parse the start time for hour, minute, seconds
; Format: 2006097132007000
;         2006097132506000

;         01234567890

n_hours   = LONG(STRMID(r_start_time,7,2));
n_minutes = LONG(STRMID(r_start_time,9,2));
n_seconds = LONG(STRMID(r_start_time,11,2));

; Save these in gds2 format so we can write them to gds2 format NetCDF file.

c_hours   = STRMID(r_start_time,7,2);
c_minutes = STRMID(r_start_time,9,2);
c_seconds = STRMID(r_start_time,11,2);

if (debug_mode) then begin
    print, debug_module + 'r_start_time = ', r_start_time;
    print, debug_module + 'n_hours      = ', n_hours;
    print, debug_module + 'n_minutes    = ', n_minutes;
    print, debug_module + 'n_seconds    = ', n_seconds;
endif

;
; Build the start date and time for global attribute in output file.
; 

; First, convert the day of year to month and day.

r_status = calday(long_attributes_values[Start_Year_index],$
                  long_attributes_values[Start_Day_index],$
                  r_month_string,$
                  r_month,$
                  r_monthday); 

l_global_start_date_utc =  STRING(long_attributes_values[Start_Year_index],$
                                  r_month,$
                                  r_monthday,$
                                  FORMAT='(I4,"-",I02,"-",I02," UTC")');
l_global_start_time_utc = c_hours + ':' + c_minutes + ':' + c_seconds + ' UTC';

gds2_global_start = STRING(long_attributes_values[Start_Year_index],r_month,r_monthday,FORMAT='(I4,I02,I02)')  + 'T' + $;
                    c_hours + c_minutes + c_seconds + "Z";

if (debug_mode) then begin
    print, debug_module + 'l_global_start_time_utc = ', l_global_start_time_utc;
    print, debug_module + 'gds2_global_start       = ', gds2_global_start;
endif

;
; Convert the time the data was first sample to seconds since 1981.  For now, add the
; 33 accummulated leap seconds to the end time. 
;

r_status = get_seconds_since_1981($
              long_attributes_values[Start_Year_index],$
              long_attributes_values[Start_Day_index],$
              n_hours,$
              n_minutes,$
              n_seconds,$
              r_seconds_since_1981);

;print, 'r_seconds_since_1981 = ', r_seconds_since_1981;

; Parse the r_end_time for hour, minute, seconds
; Format: 2006097132007000
;         2006097132506000

;         01234567890

n_hours   = LONG(STRMID(r_end_time,7,2));
n_minutes = LONG(STRMID(r_end_time,9,2));
n_seconds = LONG(STRMID(r_end_time,11,2));

c_hours   = STRMID(r_end_time,7,2);
c_minutes = STRMID(r_end_time,9,2);
c_seconds = STRMID(r_end_time,11,2);

if (debug_mode) then begin
    print, debug_module + 'r_end_time = ', r_end_time;
    print, debug_module + 'n_hours    = ', n_hours;
    print, debug_module + 'n_minutes  = ', n_minutes;
    print, debug_module + 'n_seconds  = ', n_seconds;
endif


;
; Build the start date and time for global attribute in output file. 
; 

; First, convert the day of year to month and day.

r_status = calday(long_attributes_values[End_Year_index],$
                long_attributes_values[End_Day_index],$
                r_month_string,r_month,r_monthday); 

l_global_stop_date_utc = STRING(long_attributes_values[End_Year_index],$
                                r_month,$
                                r_monthday,$
                                FORMAT='(I4,"-",I02,"-",I02," UTC")');
l_global_stop_time_utc = c_hours + ':' + c_minutes + ':' + c_seconds + ' UTC';

gds2_global_stop = STRING(long_attributes_values[End_Year_index],r_month,r_monthday,FORMAT='(I4,I02,I02)')  + 'T' + $;
                          c_hours + c_minutes + c_seconds + "Z";

if (debug_mode) then begin 
    print, debug_module + 'l_global_stop_time_utc  = ', l_global_stop_time_utc;
    print, debug_module + 'gds2_global_stop        = ', gds2_global_stop;
endif

r_status = read_character_variables_from_hdf_file($
               i_filename,$
               o_sensor_name,$
               o_start_node,$
               o_end_node,$
               o_day_or_night,$
               o_platform,$
               o_title,$
               o_comment,$
               o_dsd_entry_id,$
               i_test_parameter);

if (r_status NE SUCCESS) then begin
    status = FAILURE;
    ; Must return immediately.
    return, status
endif

;
; Create a NetCDF output file in GDS2 format.
;

r_status = create_modis_gds2_cdf_file(i_out_filename,$
                                      i_start_time_array_element,$
                                      gds2_global_start,$
                                      gds2_global_stop,$
                                      float_attributes_values[Northernmost_Latitude_index],$
                                      float_attributes_values[Southernmost_Latitude_index],$
                                      float_attributes_values[Easternmost_Longitude_index],$
                                      float_attributes_values[Westernmost_Longitude_index],$
                                      long_attributes_values[Pixels_per_Scan_Line_index],$
                                      long_attributes_values[Number_of_Scan_Lines_index],$
                                      o_title,$
                                      o_dsd_entry_id,$
                                      o_platform,$
                                      o_comment,$
                                      i_processing_type);

if (TEST_PARAMETER EQ "BAD_OUTPUT_FILE_CREATION") then begin
    r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 5: If the output file cannot be created, ERROR sigevent thrown, returns.

if (r_status NE SUCCESS) then begin
    status = FAILURE;
    msg_type = "error";
    msg = "Cannot create output file " + i_out_filename;
    print, debug_module + msg;
    l_status = error_log_writer(routine_name,msg);

    ; If the file exist, even though the status is FAILURE, we need to delete it.
    if FILE_TEST(i_out_filename) then begin
        print, debug_module + 'FILE_DELETE ' + i_out_filename;
        FILE_DELETE, i_out_filename, /QUIET;
    endif

    ; Must return immediately.
    return, status
endif

;--------------------------------------------------------------------------------
; Read cntl_pt_cols & cntl_pt_rows from file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'cntl_pt_cols';

r_status = read_control_points_variable(i_filename,i_variable_short_name,$
               r_controlled_point_cols,r_long_name,$
               r_units,r_data_type);

if (TEST_PARAMETER EQ "BAD_CNTL_PT_COLS_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

i_variable_short_name = 'cntl_pt_rows';

r_status = read_control_points_variable(i_filename,i_variable_short_name,$
               r_controlled_point_rows,r_long_name,$
               r_units,r_data_type);

if (TEST_PARAMETER EQ "BAD_CNTL_PT_ROWS_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif
tempvar = SIZE(TEMPORARY(r_controlled_point_rows)); Clear memory

i_variable_short_name = 'l2_flags';
r_status = read_hdf_l2_flag_variable(i_filename,$
               i_variable_short_name,$
               r_dataset_array,$
               r_units,$
               r_data_type);

if (TEST_PARAMETER EQ "BAD_L2_FLAGS_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    return, r_status;
endif

l2_flags_array = r_dataset_array;

i_variable_short_name = 'longitude';

r_status = read_control_points_variable(i_filename,i_variable_short_name,$
               r_longitude_subintervals, r_long_name,$
               r_units,r_lon_data_type,r_lon_fill_value);

if (TEST_PARAMETER EQ "BAD_LONGITUDE_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 6: If longitude variable cannot be read, ERROR sigevent thrown, returns.

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    return, r_status;
endif

if (debug_mode) then begin
    print, debug_module + 'i_variable_short_name = ', i_variable_short_name;
    print, debug_module + 'r_long_name           = ', r_long_name;
    print, debug_module + 'r_units               = ', r_units;
    print, debug_module + 'r_lon_data_type       = ', r_lon_data_type;
    ; Be careful to only print if the variable is defined.
    if (N_ELEMENTS(r_lon_fill_value)) then begin
        print, debug_module + 'r_lon_fill_value      = ', r_lon_fill_value;
    endif
endif

;
; Identify the bad scan lines in the r_longitude_subintervals array.
;

if (run_slow_function) then begin 
print, debug_module + 'identify_bad_scan_lines';
l_status = identify_bad_scan_lines($
             r_longitude_subintervals,$
             i_variable_short_name,$
             r_good_scan_lines_array,$
             r_num_good_scan_lines,$
             r_bad_scan_lines_array,$
             r_num_bad_scan_lines,$
             r_bad_longitude_fill_value,$
             r_scan_line_flag_array);
endif else begin
l_status = identify_bad_scan_lines_fast($
             r_longitude_subintervals,$
             i_variable_short_name,$
             r_good_scan_lines_array,$
             r_num_good_scan_lines,$
             r_bad_scan_lines_array,$
             r_num_bad_scan_lines,$
             r_bad_longitude_fill_value,$
             r_scan_line_flag_array);
endelse

if (TEST_PARAMETER EQ "BAD_LONGITUDE_SCAN_LINES") then begin
    r_num_bad_scan_lines = 1;
endif

; MODIS_L2P_ERROR_STEP 7: Identify bad scan lines in longitude, if found at least one, WARN sigevent thrown, keep going.

if (r_num_bad_scan_lines GT 0) then begin
    msg_type = "warning";
    msg = 'File ' + i_filename + ' contains bad longitudes.';
    print, debug_module + msg;
    if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_THROW_WARNING_FOR_BAD_GEOGRAPHIC_COORDINATES')) EQ 'TRUE') then begin
        donotcare = wrapper_ghrsst_notify_operator(routine_name,msg_type, msg, i_data);
    endif
    ; Keep going

    ; Because some 2002 re-processed files may have the _FillValue as -32767.0 but the actual fill value is -999.0, we must
    ; make a correction in subintervals by replacing the -999.0 with -32767.0 everywhere.

    i_array_name = 'longitude';
    if (N_ELEMENTS(r_lon_fill_value)) then begin
      if (r_lon_fill_value[0] NE r_bad_longitude_fill_value) then begin
        i_array_name = 'longitude';
        i_fill_value = r_lon_fill_value[0];
        correct_status = correct_bad_scan_lines_with_good_missing_values(i_array_name,$
                             r_num_bad_scan_lines,$
                             r_scan_line_flag_array,$
                             i_fill_value,$
                             r_longitude_subintervals);
      endif
    endif
endif

; Print the r_fill_value
if (debug_mode) then begin
    ; Be careful to only print if the variable is defined.
    if (N_ELEMENTS(r_lon_fill_value)) then begin
        print, debug_module + 'filename ' + i_filename + 'longitude:r_lon_fill_value = ', r_lon_fill_value
    endif
endif

;
; Read the latitude subintervals.
;

i_variable_short_name = 'latitude'; Should be 170 by 2030

r_status = read_control_points_variable(i_filename,i_variable_short_name,$
                           r_latitude_subintervals, r_long_name,$
                           r_units,r_lat_data_type,r_lat_fill_value);

if (TEST_PARAMETER EQ "BAD_LATITUDE_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 8: If latitude variable cannot be read, ERROR sigevent thrown, returns.

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    return, r_status;
endif

if (debug_mode) then begin
    print, debug_module + 'i_variable_short_name = ', i_variable_short_name;
    print, debug_module + 'r_long_name           = ', r_long_name;
    print, debug_module + 'r_units               = ', r_units;
    print, debug_module + 'r_lat_data_type       = ', r_lat_data_type;
    ; Be careful to only print if the variable is defined.
    if (N_ELEMENTS(r_lat_fill_value)) then begin
    print, debug_module + 'r_lat_fill_value      = ', r_lat_fill_value;
    endif
endif

;
; Identify the bad scan lines in the latitude to retrieve the r_bad_latitude_fill_value.
; This is not necessary since if there are errors in the longitude
; there will be the same number of bad scan lines in the latitude array.
; This function is not necessary if it does not matter what value we fill the latitude array with
; for bad scan lines.

if (run_slow_function) then begin 
print, debug_module + 'identify_bad_scan_lines';
l_status = identify_bad_scan_lines($
               r_latitude_subintervals,$
               i_variable_short_name,$
               r_good_scan_lines_array,$
               r_num_good_scan_lines,$
               r_bad_scan_lines_array,$
               r_num_bad_scan_lines,$
               r_bad_latitude_fill_value,$
               r_scan_line_flag_array);
endif else begin
l_status = identify_bad_scan_lines_fast($
               r_latitude_subintervals,$
               i_variable_short_name,$
               r_good_scan_lines_array,$
               r_num_good_scan_lines,$
               r_bad_scan_lines_array,$
               r_num_bad_scan_lines,$
               r_bad_latitude_fill_value,$
               r_scan_line_flag_array);
endelse

if (TEST_PARAMETER EQ "BAD_LATITUDE_SCAN_LINES") then begin
    r_num_bad_scan_lines = 1;
endif

; MODIS_L2P_ERROR_STEP 9: Identify bad scan lines in latitude, if found at least one, WARN sigevent thrown, keep going.

if (r_num_bad_scan_lines GT 0) then begin
    msg_type = "warning";
    msg = 'File ' + i_filename + ' contains bad latitudes.';
    print, msg;
    if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_THROW_WARNING_FOR_BAD_GEOGRAPHIC_COORDINATES')) EQ 'TRUE') then begin
        donotcare = wrapper_ghrsst_notify_operator(routine_name,msg_type,msg,i_data);
    endif
    ; Keep going

    ; Because some 2002 re-processed files may have the _FillValue as -32767.0 but the actual fill value is -999.0, we must
    ; make a correction in the subintervals by replacing the -999.0 with -32767.0 everywhere.

    if (N_ELEMENTS(r_lat_fill_value)) then begin
      if (r_lat_fill_value[0] NE r_bad_latitude_fill_value) then begin
        i_array_name = 'latitude';
        i_fill_value = r_lat_fill_value[0];
        correct_status = correct_bad_scan_lines_with_good_missing_values(i_array_name,$
                             r_num_bad_scan_lines,$
                             r_scan_line_flag_array,$
                             i_fill_value,$
                             r_latitude_subintervals);
      endif
    endif
endif

; Print the r_fill_value
if (debug_mode) then begin
    ; Be careful to only print if the variable is defined.
    if (N_ELEMENTS(r_lat_fill_value)) then begin
        print, routine_name, ' filename ', i_filename, ' latitude:r_lat_fill_value = ', r_lat_fill_value
    endif
endif

; 
; Remove any dateline discontinuity in the longitudes.
; 

r_dateline_crossed = 0;
size_array = size(r_controlled_point_cols);
num_lat_control_point_cols = size_array[1];   The size of the array is the 2nd element.

if (run_slow_function) then begin 
print, debug_module + 'remove_dateline_discontinuity';
l_status = remove_dateline_discontinuity(num_lat_control_point_cols,$
                                         num_lons,$
                                         r_scan_line_flag_array,$
                                         r_longitude_subintervals,$
                                         r_dateline_crossed,$
                                         r_num_longitudes_added,$
                                         r_num_longitudes_subtracted);
endif else begin
l_status = remove_dateline_discontinuity_fast(num_lat_control_point_cols,$
                                         num_lons,$
                                         r_scan_line_flag_array,$
                                         r_longitude_subintervals,$
                                         r_dateline_crossed,$
                                         r_num_longitudes_added,$
                                         r_num_longitudes_subtracted);
endelse

; If there are no bad scan lines:
;
; perform the spline fit funtions in the longitude direction of the l_longitude_array and
; r_latitude_array using the r_controlled_point_cols, the r_latitude_subintervals and 
; r_longitude_subintervals arrays.
;

l_status = perform_spline_fit_on_controlled_points( $
             r_num_bad_scan_lines,$
             r_scan_line_flag_array,$
             r_bad_longitude_fill_value,$
             r_bad_latitude_fill_value,$
             num_lons,$
             num_lats,$
             r_longitude_subintervals,$
             r_latitude_subintervals,$
             r_controlled_point_cols,$
             i_filename,$
             i_out_filename,$
             l_longitude_array,$
             l_latitude_array);

;
; Convert l_longitude_array array back to [-180,180] coordinate system
; if date line was crossed.
;

if (r_dateline_crossed EQ 1) then begin
  if (run_slow_function) then begin 
    print, debug_module + 'convert_to_negative_180_positive_180';
    r_status = convert_to_negative_180_positive_180($
                 num_lats,$
                 num_lons,$
                 r_scan_line_flag_array,$
                 l_longitude_array,$
                 r_num_longitudes_added,$
                 r_num_longitudes_subtracted);
  endif else begin
    r_status = convert_to_negative_180_positive_180_fast($
                 num_lats,$
                 num_lons,$
                 r_scan_line_flag_array,$
                 l_longitude_array,$
                 r_num_longitudes_added,$
                 r_num_longitudes_subtracted);
  endelse
endif

; If the variable r_lat_fill_value was not defined from the file, we use the hard-code default
if (~(N_ELEMENTS(r_lat_fill_value))) then begin
    r_lat_fill_value = r_bad_latitude_fill_value;
endif

;
; Write the lat & lon arrays to NetCDF file.
;

    dataset_name  = 'lat';
    standard_name = "latitude" ;
    i_long_name   = 'latitude';
    unit          = "degrees_north";
    data_type     = 'FLOAT';
    valid_min     = -90. ;
    valid_max     = 90. ;
    comment       = "geographical coordinates, WGS84 projection" ;

    r_status = write_gds2_variable(i_out_filename,$
                                   l_latitude_array,$
                                   dataset_name,$
                                   standard_name,$
                                   unit,$
                                   r_lat_fill_value,$
                                   data_type,$
                                   valid_min,$
                                   valid_max,$
                                   comment,$
                                   i_long_name);

    if (clear_memory_flag) then begin
        tempvar = SIZE(TEMPORARY(r_bad_scan_lines_array)); Clear memory
        tempvar = SIZE(TEMPORARY(r_latitude_subintervals)); Clear memory
        tempvar = SIZE(TEMPORARY(r_longitude_subintervals)); Clear memory
        tempvar = SIZE(TEMPORARY(r_good_scan_lines_array)); Clear memory
        tempvar = SIZE(TEMPORARY(r_controlled_point_cols)); Clear memory
        tempvar = SIZE(TEMPORARY(l_latitude_array)); Clear memory
    endif

    ; MODIS_L2P_ERROR_STEP 10: If cannot write 'lat' variable, ERROR sigevent thrown, returns.

    if (TEST_PARAMETER EQ "BAD_LATITUDE_VARIABLE_WRITE") then begin
        r_status = FAILURE;
    endif

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        FILE_DELETE, i_out_filename, /QUIET;
        ; Must return immediately.
        return, r_status
    endif

    ; If the variable r_lon_fill_value was not defined from the file, we use the hard-code default
    if (~(N_ELEMENTS(r_lon_fill_value))) then begin
        r_lon_fill_value = r_bad_longitude_fill_value;
    endif

    dataset_name  = 'lon';
    standard_name = "longitude" ;
    i_long_name   = 'longitude';
    unit          = "degrees_east";
    data_type     = 'FLOAT';
    valid_min     = -180. ;
    valid_max     = 180. ;
    comment       = "geographical coordinates, WGS84 projection" ;

    r_status = write_gds2_variable(i_out_filename,$
                                   l_longitude_array,$
                                   dataset_name,$
                                   standard_name,$
                                   unit,$
                                   r_lon_fill_value,$
                                   data_type,$
                                   valid_min,$
                                   valid_max,$
                                   comment,$
                                   i_long_name);

    if (clear_memory_flag) then begin
        tempvar = SIZE(TEMPORARY(l_longitude_array)); Clear memory
    endif

    ; MODIS_L2P_ERROR_STEP 11: If cannot write 'lon' variable, ERROR sigevent thrown, returns.

    if (TEST_PARAMETER EQ "BAD_LON_VARIABLE_WRITE") then begin
        r_status = FAILURE;
    endif

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        FILE_DELETE, i_out_filename, /QUIET;
        ; Must return immediately.
        return, r_status
     endif

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Read arrays from HDF file and write to NetCDF file.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
write_time_variable_flag = 1;  Flag to allow developer to ignore the writing of the time variable.

if (write_time_variable_flag EQ 1) then begin
    time_array = LONARR(1);
    time_array[0] = r_seconds_since_1981;
    long_name =  'reference time of sst file'; 
    standard_name = 'time' 
    dataset_name  = 'time';
    unit      = 'seconds since 1981-01-01 00:00:00';
    data_type = 'LONG';
    comment = ' ';

    r_status = write_gds2_variable(i_out_filename,$
                                   time_array,$
                                   dataset_name,$
                                   standard_name,$
                                   unit,$
                                   undefined_fill_value,$
                                   data_type,$
                                   undefined_valid_min,$
                                   undefined_valid_max,$
                                   comment,$
                                   long_name);

if (TEST_PARAMETER EQ "BAD_TIME_VARIABLE_WRITE") then begin
    r_status = FAILURE;
endif

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        FILE_DELETE, i_out_filename, /QUIET;
        ; Must return immediately.
        return, r_status
    endif
endif;

i_variable_short_name = 'sst';

r_status = read_hdf_variable(i_filename,i_variable_short_name,$
                             r_dataset_array, r_slope,$
                             r_intercept,r_data_type,r_sst_fill_value,r_valid_min,r_valid_max);

if (TEST_PARAMETER EQ "BAD_SST_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 12: If cannot read 'sst' variable, ERROR sigevent thrown, returns.

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

;
; Save the 'sst' array for later processing.
;

saved_sst_array = r_dataset_array;

i_dataset_name = 'sea_surface_temperature';

if (strcmp(i_convert_to_kelvin,'yes')) then begin
    i_units = 'kelvin';
    r_intercept += CELSIUS_TO_KELVIN_CONVERSION_FACTOR;
end else begin
    i_units = 'celsius';
end

; If the fill value is provided from HDF file, we attempt to use it
if (N_ELEMENTS(r_sst_fill_value)) then begin
    ; Do nothing, the variable r_fill_value is already contained the value we want.
endif else begin
    ; If the fill value is not provided, we use a constant, which is hard-coded.
    r_sst_fill_value = MISSING_VALUE_SST;
    if (debug_mode) then begin
        msg = routine_name + ':' + 'Fill value missing for variable ' + i_dataset_name + '.  Setting to default value ' + STRTRIM(STRING(MISSING_VALUE_SST),2);
        print, msg;
    endif
endelse

; If the valid_min value is provided from HDF file, we attempt to use it

if (N_ELEMENTS(r_valid_min)) then begin
    ; Do nothing, the variable is already contained the value we want.
endif else begin
    ; If the value is not provided, we use a constant, which is hard-coded.
    r_valid_min = -1000;
endelse

; If the valid_max value is provided from HDF file, we attempt to use it

if (N_ELEMENTS(r_valid_max)) then begin
    ; Do nothing, the variable is already contained the value we want.
endif else begin
    ; If the value is not provided, we use a constant, which is hard-coded.
    r_valid_max = 8000;
endelse

    dataset_name = 'sea_surface_temperature';
    standard_name = 'sea_surface_skin_temperature';
    i_coordinates = "lon lat";
    long_name =  'sea surface temperature'; 
    source = 'NASA and University of Miami';
    comment = 'sea surface temperature from thermal IR (11 um) channels';

    r_status = write_gds2_variable(i_out_filename,$
                                   r_dataset_array,$
                                   dataset_name,$
                                   standard_name,$
                                   i_units,$
                                   r_sst_fill_value,$
                                   r_data_type,$
                                   r_valid_min,$
                                   r_valid_max,$
                                   comment,$
                                   long_name,$
                                   r_slope,$
                                   r_intercept,$
                                   source,$
                                   i_coordinates);

    ; MODIS_L2P_ERROR_STEP 13: If cannot write 'sea_surface_temperature', ERROR sigevent thrown, returns.
if (TEST_PARAMETER EQ "BAD_SEA_SURFACE_TEMPERATURE_VARIABLE_WRITE") then begin
    r_status = FAILURE;
endif

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        FILE_DELETE, i_out_filename, /QUIET;
        ; Must return immediately.
        return, r_status
     endif

;--------------------------------------------------------------------------------
; Read msec HDF file and write to NetCDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'msec';

r_status = read_one_dim_hdf_variable(i_filename,i_variable_short_name,$
               r_dataset_array, r_units,$
               r_data_type);

if (TEST_PARAMETER EQ "BAD_MSEC_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

;  Convert to seconds first, then subtract each value from the reference time.

r_dataset_array = (r_dataset_array / 1000.0) - start_seconds;

; Create a 2 dimensional array and duplicate each value across all columns.

dtime_array = INTARR(long_attributes_values[Pixels_per_Scan_Line_index],$
                     long_attributes_values[Number_of_Scan_Lines_index]);

; Old and in-efficient method of assigning variable values.

;for i = 0,  (long_attributes_values[Pixels_per_Scan_Line_index] - 1) do begin
;    for j = 0,  (long_attributes_values[Number_of_Scan_Lines_index] - 1) do begin
;         dtime_array[i,j] = r_dataset_array[j]; 
;    endfor 
;endfor 

; Since IDL is efficient with array assignments, we take advantage of it to
; assign the 2nd dimension with dtime_array[i,*] = r_dataset_array[*].

for i = 0,  (long_attributes_values[Pixels_per_Scan_Line_index] - 1) do begin
    dtime_array[i,*] = r_dataset_array[*]; 
endfor 

    dataset_name = 'sst_dtime';
    units = 'seconds';
    data_type = 'SHORT';
    slope = 1;
    intercept = 0;
    fill_value = -32768;
    valid_min = -32767;
    valid_max =  32767;
    long_name = 'time difference from reference time';
    coordinates = "lon lat"
    comment = "time plus sst_dtime gives seconds after 00:00:00 UTC January 1, 1981"; 

    r_status = write_gds2_variable(i_out_filename,$
                                   dtime_array,$
                                   dataset_name,$
                                   undefined_standard_name,$
                                   units,$
                                   fill_value,$
                                   data_type,$
                                   valid_min,$
                                   valid_max,$
                                   comment,$
                                   long_name,$
                                   slope,$
                                   intercept,$
                                   undefined_source,$
                                   coordinates);
    if (clear_memory_flag) then begin
        tempvar = SIZE(TEMPORARY(dtime_array)); Clear memory
    endif

    ; MODIS_L2P_ERROR_STEP 14: If cannot write 'sst_dtime' variable, ERROR sigevent thrown, returns.

    if (TEST_PARAMETER EQ "BAD_SST_DTIME_VARIABLE_WRITE") then begin
        r_status = FAILURE;
    endif

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        FILE_DELETE, i_out_filename, /QUIET;
        ; Must return immediately.
        return, r_status
     endif

;--------------------------------------------------------------------------------
; Read bias_sst from HDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'bias_sst';

r_status = read_hdf_variable(i_filename,i_variable_short_name,$
               r_bias_sst, r_slope_bias_error,$
               r_intercept_bias_error,r_data_type);

; MODIS_L2P_ERROR_STEP 15: If cannot read 'bias_sst' variable, ERROR sigevent thrown, returns.
if (TEST_PARAMETER EQ "BAD_BIAS_SST_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' in file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

;--------------------------------------------------------------------------------
; Read stdv_sst from HDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'stdv_sst';

r_status = read_hdf_variable(i_filename,i_variable_short_name,$
               r_stdv_sst, r_slope_standard_deviation_sst,$
               r_intercept_standard_deviation_sst,r_data_type);

; MODIS_L2P_ERROR_STEP 16: If cannot read 'stdv_sst' variable, ERROR sigevent thrown, returns.
if (TEST_PARAMETER EQ "BAD_STDV_SST_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' in file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

;--------------------------------------------------------------------------------
; Read qual_sst from HDF file and write to NetCDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'qual_sst';

r_status = read_hdf_variable(i_filename,i_variable_short_name,$
               r_qual_sst, r_slope,$
               r_intercept,r_data_type);

; MODIS_L2P_ERROR_STEP 17: If cannot read 'qual_sst' variable, ERROR sigevent thrown, returns.
if (TEST_PARAMETER EQ "BAD_QUAL_SST_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' in file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status 
endif

; Do a sanity check on the size of the dataset name 'qual_sst'.
if ((SIZE(r_qual_sst,/N_ELEMENTS)) LE 0) then begin
    dataset_name = 'qual_sst';
    msg_type = "error";
    msg = 'Cannot process variable ' + dataset_name + ' in file ' + i_out_filename + ' because it does not have any elements or is undefined.';
    print, debug_module + msg; 
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif; end to ((SIZE(r_qual_sst,/N_ELEMENTS)) LE 0)

; Build an array to update the elements with.

if (SIZE(r_qual_sst,/N_ELEMENTS) GT 0) then begin
r_updated_qual_sst = r_qual_sst;

r_status = perform_proximity_confidence_mapping(num_lons, num_lats,$
               saved_sst_array,$
               r_qual_sst,$
               r_bias_sst,$
               r_stdv_sst,$
               r_updated_qual_sst);

    dataset_name = 'quality_level';
    fill_value = BYTE_FILL_VALUE; 
    valid_min = 0B;
    valid_max = 5B;
    long_name = 'quality level of SST pixel';
    coordinates = "lon lat"
    comment = "thermal IR SST proximity confidence value; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";
    grid_mapping = "polar_stereographic";
    flag_meanings = "no_data bad_data worst_quality low_quality acceptable_quality best_quality";

    ; The flag_values is an array of 6 elements from 0B to 5B.  We manually set these values.

    flag_values = BYTARR(6);
    flag_values[0] = 0B;
    flag_values[1] = 1B;
    flag_values[2] = 2B;
    flag_values[3] = 3B;
    flag_values[4] = 4B;
    flag_values[5] = 5B;

    r_status = write_gds2_variable(i_out_filename,$
                                   r_updated_qual_sst,$
                                   dataset_name,$
                                   undefined_standard_name,$
                                   undefined_units,$
                                   fill_value,$
                                   r_data_type,$
                                   valid_min,$
                                   valid_max,$
                                   comment,$
                                   long_name,$
                                   undefined_slope,$
                                   undefined_intercept,$
                                   undefined_source,$
                                   coordinates,$
                                   flag_values,$
                                   flag_meanings);

if (clear_memory_flag) then begin
    tempvar = SIZE(TEMPORARY(r_dataset_array)); Clear memory
    tempvar = SIZE(TEMPORARY(saved_sst_array)); Clear memory
    tempvar = SIZE(TEMPORARY(r_qual_sst)); Clear memory
    tempvar = SIZE(TEMPORARY(r_updated_qual_sst)); Clear memory
endif

if (TEST_PARAMETER EQ "BAD_PROXIMITY_CONFIDENCE_VARIABLE_WRITE") then begin
     r_status = FAILURE;
endif

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        FILE_DELETE, i_out_filename, /QUIET;
        ; Must return immediately.
        return, r_status
     endif

endif; end to if (SIZE(r_qual_sst,/N_ELEMENTS) GT 0)

; Do a sanity check on the size of the dataset name 'bias_sst'.
if ((SIZE(r_bias_sst,/N_ELEMENTS)) LE 0) then begin
    dataset_name = 'bias_sst';
    msg_type = "error";
    msg = 'Cannot process variable ' + dataset_name + ' in file ' + i_out_filename + ' because it does not have any elements or is undefined.';
    print, debug_module + msg; 
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif; end to if ((SIZE(r_bias_sst,/N_ELEMENTS)) LE 0)

if ((SIZE(r_bias_sst,/N_ELEMENTS)) GT 0) then begin
;
; Write the other byte arrays.
;

i_dataset_name = 'SSES_bias_error';
if (strcmp(i_convert_to_kelvin,'yes')) then begin
    i_units = 'kelvin';
end else begin
    i_units = 'celsius';
end
r_fill_value = BYTE_FILL_VALUE;
i_valid_min = -127B;
i_valid_max = SIGNED_BYTE_VALID_MAX; place holder
i_coordinates = "lon lat";
i_long_name =  'SSES bias error based on proximity confidence flags';
i_source = ''; 
i_comment = "thermal IR SST bias error; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";

; Must allocate an integer array to convert from unsigned byte to signed byte.
size_array = size(r_bias_sst);
num_columns = size_array[1];
num_rows    = size_array[2];
r_bias_sst_as_int = INTARR(num_columns,num_rows,/NOZERO);

; If we are not processing from original NetCDF file, use the "converted" intercept value. 
if (GETENV('GHRSST_MODIS_L2P_CONVERTING_FROM_ORIGINAL_NETCDF_FILES') NE 'true') then begin
    ; The array returned at the end is of type integer.
    l_status = convert_to_signed_byte(r_bias_sst,r_intercept_bias_error,r_bias_sst_as_int);

    ; The type of r_intercept_bias_error for some reason is double.
    ; We will convert it back to float to avoid having value such as:
    ;
    ;     add_offset = 0.199999999999999 
    ; 

    intercept_as_float_arr = FLOAT(r_intercept_bias_error);
    intercept_as_float_value = intercept_as_float_arr[0];

    ; Write the integer array.  NetCDF should do the conversion from integer to byte on your behalf.
    dataset_name = 'sses_bias';
    r_status = write_gds2_variable(i_out_filename,$
                                   r_bias_sst_as_int,$
                                   dataset_name,$
                                   undefined_standard_name,$
                                   i_units,$
                                   r_fill_value,$
                                   r_data_type,$
                                   i_valid_min,$
                                   i_valid_max,$
                                   i_comment,$
                                   i_long_name,$
                                   r_slope_bias_error[0],$
                                   intercept_as_float_value,$
                                   undefined_source,$
                                   i_coordinates);
    if (clear_memory_flag) then begin
        tempvar = SIZE(TEMPORARY(r_bias_sst)); Clear memory
        tempvar = SIZE(TEMPORARY(r_bias_sst_as_int)); Clear memory
    endif
endif else begin
    ; If we are processing from original NetCDF file, use the different scaling to convert from short to byte and also reset the scale factor and offset.
    scaling_status = apply_scaling_from_short_to_byte($
                         r_slope_bias_error,$
                         r_bias_sst,$
                         o_byte_variable_array,$
                         o_byte_scale_factor,$
                         o_byte_add_offset);

    ; Write the integer array.  NetCDF should do the conversion from integer to byte on your behalf.
    dataset_name = 'sses_bias';
    r_status = write_gds2_variable(i_out_filename,$
                                   o_byte_variable_array,$
                                   dataset_name,$
                                   undefined_standard_name,$
                                   i_units,$
                                   r_fill_value,$
                                   r_data_type,$
                                   i_valid_min,$
                                   i_valid_max,$
                                   i_comment,$
                                   i_long_name,$
                                   o_byte_scale_factor,$
                                   o_byte_add_offset,$
                                   undefined_source,$
                                   i_coordinates);
    if (clear_memory_flag) then begin
        tempvar = SIZE(TEMPORARY(r_bias_sst)); Clear memory
        tempvar = SIZE(TEMPORARY(r_bias_sst_as_int)); Clear memory
        tempvar = SIZE(TEMPORARY(o_byte_variable_array)); Clear memory
    endif
endelse

if (TEST_PARAMETER EQ "BAD_BIAS_ERROR_VARIABLE_WRITE") then begin
     r_status = FAILURE;
endif

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        FILE_DELETE, i_out_filename, /QUIET;
        ; Must return immediately.
        return, r_status
     endif

endif ; end to if ((SIZE(r_bias_sst,/N_ELEMENTS)) GT 0) 

; Do a sanity check on the size of the dataset name 'stdv_sst'.
if ((SIZE(r_stdv_sst,/N_ELEMENTS)) LE 0) then begin
    dataset_name = 'stdv_sst';
    msg_type = "error";
    msg = 'Cannot process variable ' + dataset_name + ' in file ' + i_out_filename + ' because it does not have any elements or is undefined.';
    print, debug_module + msg; 
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif; end to if ((SIZE(r_stdv_sst,/N_ELEMENTS)) LE 0)

if ((SIZE(r_stdv_sst,/N_ELEMENTS)) GT 0) then begin

i_dataset_name = 'SSES_standard_deviation_error';
if (strcmp(i_convert_to_kelvin,'yes')) then begin
    i_units = 'kelvin';
end else begin
    i_units = 'celsius';
end
r_fill_value = BYTE_FILL_VALUE;
i_valid_min = -127B;
i_valid_max = SIGNED_BYTE_VALID_MAX; place holder
i_coordinates = 'lon lat';
i_long_name =  'SSES standard deviation error based on proximity confidence flags';
i_source = ''; 
i_comment = "thermal IR SST standard deviation error; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";

r_stdv_sst_as_int = INTARR(num_columns,num_rows,/NOZERO);


; If we are not processing from original NetCDF file, use the "converted" intercept value.
if (GETENV('GHRSST_MODIS_L2P_CONVERTING_FROM_ORIGINAL_NETCDF_FILES') NE 'true') then begin
    l_status = convert_to_signed_byte(r_stdv_sst,r_intercept_standard_deviation_sst,r_stdv_sst_as_int);

    ; The type of r_intercept_standard_deviation_sst for some reason is double.
    ; We will convert it back to float to avoid having value such as in the attribute dump:
    ;
    ;     add_offset = 0.199999999999999 
    ; 

    intercept_as_float_arr   = FLOAT(r_intercept_standard_deviation_sst);
    intercept_as_float_value = intercept_as_float_arr[0];

    ; Write the integer array.  NetCDF should do the conversion from integer to byte on your behalf.
    dataset_name = 'sses_standard_deviation';
    r_status = write_gds2_variable(i_out_filename,$
                                   r_stdv_sst_as_int,$
                                   dataset_name,$
                                   undefined_standard_name,$
                                   i_units,$
                                   r_fill_value,$
                                   r_data_type,$
                                   i_valid_min,$
                                   i_valid_max,$
                                   i_comment,$
                                   i_long_name,$
                                   r_slope_standard_deviation_sst,$
                                   intercept_as_float_value,$
                                   undefined_source,$
                                   i_coordinates);

    if (clear_memory_flag) then begin
        tempvar = SIZE(TEMPORARY(r_stdv_sst)); Clear memory
        tempvar = SIZE(TEMPORARY(r_intercept_standard_deviation_sst)); Clear memory
        tempvar = SIZE(TEMPORARY(r_stdv_sst_as_int)); Clear memory
    endif
endif else begin
    ; If we are processing from original NetCDF file, use the different scaling to convert from short to byte and also reset the scale factor and offset.
    scaling_status = apply_scaling_from_short_to_byte_for_stdv_variable($
                         r_slope_standard_deviation_sst,$
                         r_stdv_sst,$
                         o_byte_variable_array,$
                         o_byte_scale_factor,$
                         o_byte_add_offset);

    dataset_name = 'sses_standard_deviation';

    r_status = write_gds2_variable(i_out_filename,$
                                   o_byte_variable_array,$
                                   dataset_name,$
                                   undefined_standard_name,$
                                   i_units,$
                                   r_fill_value,$
                                   r_data_type,$
                                   i_valid_min,$
                                   i_valid_max,$
                                   i_comment,$
                                   i_long_name,$
                                   o_byte_scale_factor,$
                                   o_byte_add_offset,$
                                   undefined_source,$
                                   i_coordinates);
    if (clear_memory_flag) then begin
        tempvar = SIZE(TEMPORARY(r_stdv_sst)); Clear memory
        tempvar = SIZE(TEMPORARY(o_byte_variable_array)); Clear memory
        tempvar = SIZE(TEMPORARY(r_stdv_sst_as_int)); Clear memory
    endif
endelse

if (TEST_PARAMETER EQ "BAD_STANDARD_DEVIATION_ERROR_VARIABLE_WRITE") then begin
     r_status = FAILURE;
endif

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        FILE_DELETE, i_out_filename, /QUIET;
        ; Must return immediately.
        return, r_status
     endif

endif; end to if ((SIZE(r_stdv_sst,/N_ELEMENTS)) GT 0)

;--------------------------------------------------------------------------------
; Additional byte arrays for various flags.
;--------------------------------------------------------------------------------

;
; Write the confidence_flag to NetCDF file as l2p_flags variable.
;

confidence_flag = BYTARR(long_attributes_values[Pixels_per_Scan_Line_index],$
                         long_attributes_values[Number_of_Scan_Lines_index]);

i_dataset_name = 'confidence_flag';
i_units = 'none';
r_data_type = 'BYTE';
i_long_name = 'confidence_flag';
i_comment = "b0 : 1 = potential side lobe contamination; b1 : 1 = relaxed rain contamination suspected; b2 : 1 = TMI SST retrieved in SST < 285K; b3 : 1 = high wind speed retrieval; b4 : 1 = sea ice retrieval for MW data; b5 : 1 = sun glint;  b6 : 1 = L2 native bias and standard deviation; b7 : 1 = L2 native confidence value";

    ; For GDS2 the variable name changed from confidence_flag to l2p_flags
    ; Note about confidence_flag for future: If there were other bits that need to be set, they will need to be set here.
    ; by adding adding function that does explicit bit setting.

    mask_status = unmask(l2_flags_array,r_mask_array);
    confidence_mask_array = r_mask_array[1,*];  Get just the 2nd bit.
    mask_indices_array = where (confidence_mask_array EQ 1B,num_elements);
    confidence_flag[mask_indices_array] = 2B;

    if (clear_memory_flag) then begin
        tempvar = SIZE(TEMPORARY(l2_flags_array)); Clear memory
        tempvar = SIZE(TEMPORARY(r_mask_array)); Clear memory
    endif

    dataset_name = 'l2p_flags';
    long_name = "L2P flags";
    coordinates = "lon lat";
    valid_min = 0;
    valid_max = 16;
    flag_meanings = "microwave land ice lake river";  We will add our own flag meanings as more flags are required.
    flag_masks = INTARR(5);
    flag_masks[0]  = 1;
    flag_masks[1]  = 2;
    flag_masks[2]  = 4;
    flag_masks[3]  = 8;
    flag_masks[4]  = 16;
    comment = "These flags can be used to further filter data variables";
    r_data_type = 'SHORT';

    r_status = write_gds2_variable(i_out_filename,$
                                   confidence_flag,$
                                   dataset_name,$
                                   undefined_standard_name,$
                                   undefined_units,$
                                   undefined_fill_value,$
                                   r_data_type,$
                                   valid_min,$
                                   valid_max,$
                                   comment,$
                                   long_name,$
                                   undefined_slope,$
                                   undefined_intercept,$
                                   undefined_source,$
                                   coordinates,$
                                   undefined_flag_values,$
                                   flag_meanings,$
                                   undefined_grid_mapping,$
                                   undefined_time_offset,$
                                   undefined_height,$
                                   flag_masks);

if (clear_memory_flag) then begin
    tempvar = SIZE(TEMPORARY(confidence_flag)); Clear memory
endif

    if (TEST_PARAMETER EQ "BAD_L2P_FLAGS_VARIABLE_WRITE") then begin
         r_status = FAILURE;
    endif

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        FILE_DELETE, i_out_filename, /QUIET;
        ; Must return immediately.
        return, r_status
    endif

;--------------------------------------------------------------------------------
; If this dataset is taken at night, convert additional variables
; For day dataset, convert additional variables as well.
;--------------------------------------------------------------------------------

;print, 'convert_modis_from_hdf_to_gds2_netcdf: o_day_or_night = ', o_day_or_night; 

l_status = convert_additional_night_hdf_variables_to_gds2(i_filename,i_out_filename,num_lons,$
               num_lats,i_convert_to_kelvin,$
               r_num_bad_scan_lines,$
               r_scan_line_flag_array,$
               i_test_parameter) 

l_status = convert_additional_day_hdf_variables_to_gds2(i_filename,i_out_filename,$
               r_num_bad_scan_lines,$
               r_scan_line_flag_array,$
               i_test_parameter);

if (clear_memory_flag) then begin
    tempvar = SIZE(TEMPORARY(r_scan_line_flag_array)); Clear memory
endif

;
; If the data type is Refined, append the ancillary data from the Filled Quicklook
; to the MODIS L2P.
;

process_filled_quicklook = 0; This flag allow us to turn off the appending of the ancillary variables from the refined files.  As of 5/2014, PODAAC is currently not filling MODIS L2P with ancillary variables.

if (i_processing_type EQ "REFINED") AND (process_filled_quicklook EQ 1) then begin
    ; Extract the directory from the input data file name.
    scratch_directory = FILE_DIRNAME(i_filename);

    ; Extract the name only from the refined MODIS L2P
    filled_quick_name_only = FILE_BASENAME(i_out_filename); 

    ; Build the Filled Quicklook MODIS L2P filename.
    ; Assumption: the file has been uncompressed from BZ2 to .nc

    filled_quicklook_filename = scratch_directory + "/" + filled_quick_name_only;

    if (debug_mode) then begin
        print, debug_module + 'i_filename                = ', i_filename;
        print, debug_module + 'i_out_filename            = ', i_out_filename;
        print, debug_module + 'filled_quick_name_only    = ', filled_quick_name_only;
        print, debug_module + 'filled_quicklook_filename = ', filled_quicklook_filename;
        print, debug_module + 'FILE_TEST(filled_quicklook_filename) = ', FILE_TEST(filled_quicklook_filename);
    endif

    ; If the file has been previously uncompressed by the Perl code,
    ; we will append the ancillary data to the Refined MODIS L2P.

    if (FILE_TEST(filled_quicklook_filename) EQ 1) then begin

        ; Build the list of variable names to loop through.  Note that for GDS2 file format, the variable name is dt_analysis
        ; where for GDS1 format, the variable name is DT_analysis.
        ancillary_variable_names_array = ["aerosol_optical_depth",   $
                                          "dt_analysis",             $
                                          "sea_ice_fraction",        $
                                          "surface_solar_irradiance",$
                                          "wind_speed"];

        ; For each variable, attempt to append it to the Refined MODIS L2P.

        for variable_name_index = 0, (size(ancillary_variable_names_array,/N_ELEMENTS) - 1) do begin
          l_status = append_ancillary_data_variable_gds2(filled_quicklook_filename,$
                                                         ancillary_variable_names_array[variable_name_index],$
                                                         i_out_filename,$
                                                         o_day_or_night,$
                                                         o_start_node,$
                                                         o_end_node);
        endfor

        ; Delete the staged Filled Quicklook file.
;        FILE_DELETE, filled_quicklook_filename, /QUIET;
    endif
endif

; If not processing filled quicklook, remove the staged file.
if (i_processing_type EQ "REFINED") AND (process_filled_quicklook EQ 0) then begin
    ; Extract the directory from the input data file name.
    scratch_directory = FILE_DIRNAME(i_filename);

    ; Extract the name only from the refined MODIS L2P
    filled_quick_name_only = FILE_BASENAME(i_out_filename); 

    ; Build the Filled Quicklook MODIS L2P filename.
    ; Assumption: the file has been uncompressed from BZ2 to .nc

    filled_quicklook_filename = scratch_directory + "/" + filled_quick_name_only;

    ; If the file has been previously uncompressed by the Perl code, we delete it.

    if (FILE_TEST(filled_quicklook_filename) EQ 1) then begin
        ; Delete the staged Filled Quicklook file.
        FILE_DELETE, filled_quicklook_filename, /QUIET;
    endif
endif

  ; Moved the writing of wind_speed and dt_analysis variables toward the end after the ancillary filling (if it is being done).
  ; The rationale is NetCDF does not support deleting of variables within a file.
  ; If the variable(s) has been filled (written before by using is_netcdf_variable_in_file() function) we don't write them again.

  ; We write 2 variables that the MODIS L2P GDS1 does not have but the GDS2 is required: wind_speed and dt_analysis 

  if ((GETENV('GHRSST_IGNORE_WRITE_WIND_SPEED_VARIABLE_IN_GDS2_FILE') EQ 'false') OR $
      (GETENV('GHRSST_IGNORE_WRITE_WIND_SPEED_VARIABLE_IN_GDS2_FILE') EQ ''     )) then begin

    dataset_name = 'wind_speed';

    if (is_netcdf_variable_in_file(i_out_filename,dataset_name) EQ 0) then begin
        ;
        ; Write wind_speed variable.
        ;

        r_status = write_optional_gds2_wind_speed_variable(i_out_filename,$
                                                           long_attributes_values);

        if (TEST_PARAMETER EQ "BAD_WIND_SPEED_VARIABLE_WRITE") then begin
             r_status = FAILURE;
        endif

        if (r_status EQ FAILURE) then begin
            msg_type = "error";
            msg = 'Cannot write variable ' + dataset_name + ' to file ' + i_out_filename;
            print, debug_module + msg;
            donotcare = error_log_writer(routine_name,msg);
            FILE_DELETE, i_out_filename, /QUIET;
            ; Must return immediately.
            return, r_status
        endif
    endif else begin; endif  (is_netcdf_variable_in_file(i_out_filename,'wind_speed') EQ 0)
        if (debug_mode) then begin
            msg = 'Variable ' + dataset_name + ' has been written already.';
            print, debug_module + msg;
        endif
    endelse
  endif ; endif (GETENV('GHRSST_IGNORE_WRITE_WIND_SPEED_VARIABLE_IN_GDS2_FILE') EQ 'false')

  if ((GETENV('GHRSST_IGNORE_WRITE_DT_ANALYSIS_VARIABLE_IN_GDS2_FILE') EQ 'false') OR $
      (GETENV('GHRSST_IGNORE_WRITE_DT_ANALYSIS_VARIABLE_IN_GDS2_FILE') EQ ''     )) then begin

    dataset_name = 'dt_analysis';

    if (is_netcdf_variable_in_file(i_out_filename,dataset_name) EQ 0) then begin
        ;
        ; Write dt_analysis variable.
        ;

        r_status = write_optional_gds2_dt_analysis_variable(i_out_filename,$
                                                            long_attributes_values);

        if (TEST_PARAMETER EQ "BAD_DT_ANALYSIS_VARIABLE_WRITE") then begin
             r_status = FAILURE;
        endif

        if (r_status EQ FAILURE) then begin
            msg_type = "error";
            msg = 'Cannot write variable ' + dataset_name + ' to file ' + i_out_filename;
            print, debug_module + msg;
            donotcare = error_log_writer(routine_name,msg);
            FILE_DELETE, i_out_filename, /QUIET;
            ; Must return immediately.
            return, r_status
        endif
    endif else begin; endif (is_netcdf_variable_in_file(i_out_filename,'dt_analysis') EQ 0)
        if (debug_mode) then begin
            msg = 'Variable ' + dataset_name + ' has been written already.';
            print, debug_module + msg;
        endif
    endelse
  endif ; endif (GETENV('GHRSST_IGNORE_WRITE_DT_ANALYSIS_VARIABLE_IN_GDS2_FILE') EQ 'false')

; ---------- Close up shop ---------- 

routine_end = SYSTIME(/SECONDS);
routine_duration = routine_end - routine_start;

if (debug_mode) then begin
     print, debug_module + 'routine_duration ', routine_duration;

     bytes_mem_end = MEMORY(/CURRENT);
     message = 'MEMORY_CURRENT ';
     sentence = debug_module + message + STRTRIM(STRING(bytes_mem_end),2)+' BYTES';
;print, sentence;
     megab_mem = bytes_mem_end / 1048576.;
     sentence = debug_module + message + STRTRIM(STRING(megab_mem),2)+' MEGABYTES';
;print, sentence;
     message = 'MEMORY_DIFFERENCE ';
     sentence = debug_module + message + STRTRIM(STRING(bytes_mem_end - bytes_mem_start),2)+' BYTES';
     print, sentence;
     megab_mem_difference = (bytes_mem_end - bytes_mem_start) / 1048576.0;
     sentence = debug_module + message + STRTRIM(STRING(megab_mem_difference),2)+' MEGABYTES';
     print, sentence
endif

if FILE_TEST(i_out_filename) then begin
    output_file_size_as_string = STRTRIM(STRING((FILE_INFO(i_out_filename)).SIZE),2);
    routine_duration_as_string = STRTRIM(STRING(routine_duration),2);
    print, debug_module + i_filename + ':' +  i_out_filename + ':' + output_file_size_as_string + ':' + routine_duration_as_string;
endif

return, r_status
end
