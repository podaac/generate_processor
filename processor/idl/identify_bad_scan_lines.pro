;  Copyright 2006, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id: identify_bad_scan_lines.pro,v 1.3 2006/10/17 22:44:00 qchau Exp $
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CVS
; New Request #xxxx

FUNCTION identify_bad_scan_lines, $
             i_geolocation_array, $
             i_array_name, $
             r_good_scan_lines_array, $
             r_num_good_scan_lines, $
             r_bad_scan_lines_array, $
             r_num_bad_scan_lines, $
             r_bad_fill_value, $
             r_scan_line_flag_array

; Function identify the bad scan lines containing values out of the [-180.0,180.0] range for
; longitude and [-90.0,90.0] for latitudes.
;
; Assumptions:
;
;   1. TBD.
;

;------------------------------------------------------------------------------------------------

; Load constants.

@modis_data_config.cfg

; Define local variables.

r_status = SUCCESS;

VALID_LON_MIN = -181.0;    Bryan Franz suggested we keep it safe by using -181.0 so we wouldn't
VALID_LON_MAX =  181.0;    toss out a -180.000001
VALID_LAT_MIN = -91.0;     Same goes for the latitude.
VALID_LAT_MAX =  91.0;

; We set the min_value according to the name of the array whether it is
; latitude or longitude.
;

if (i_array_name EQ 'latitude') then begin
    min_valid_value = VALID_LAT_MIN; 
    max_valid_value = VALID_LAT_MAX; 
    r_bad_fill_value = LAT_FILL_VALUE; 
endif else begin
    if (i_array_name EQ 'longitude') then begin
        min_valid_value = VALID_LON_MIN; 
        max_valid_value = VALID_LON_MAX; 
        r_bad_fill_value = LON_FILL_VALUE; 
    endif else begin
        print, 'identify_bad_scan_lines: ERROR, Unrecognize array name: ', i_array_name;
        print, 'identify_bad_scan_lines: Valid values are latitude and longitude';
        r_status = FAILURE;
        ; Must return immediately.
        return, r_status
    end
endelse

; Get the size of the incoming array.

size_array = size(i_geolocation_array);

; Extract individual dimensions.
;
; Indices      Value
;   0          number of dimensions
;   1          columns
;   2          rows
;   3          data type
;   4          number of elements

if (size_array[0] ne 2) then begin
    print, 'convert_modis_from_hdf_to_netcdf: ERROR, Incoming array must be of two dimensions';
    r_status = FAILURE;
    ; Must return immediately.
    return, r_status
endif

num_columns = size_array[1]; 
num_rows    = size_array[2]; 

;help, num_columns;
;help, num_rows;

; Allocate the return array.  We will need at most num_rows

r_good_scan_lines_array = LONARR(num_rows);
r_num_good_scan_lines     = 0L;
r_bad_scan_lines_array = LONARR(num_rows);
r_num_bad_scan_lines     = 0L;
r_scan_line_flag_array   = LONARR(num_rows);

;help, r_bad_scan_lines_array;

;
; For each row, if one value among the column is out of range, we mark the row as
; bad.  Save the index of the row in the r_bad_scan_lines_array.
;
; a = [[0,0,0],[2,3,3]]
;
; print, a
;       0       0       0
;       2       3       3
; help, a
;       A               INT       = Array[3, 2]
;
; The columns is 3, the rows is 2.
;

bad_scan_lines_index  = 0L; 
good_scan_lines_index = 0L; 

l_fill_value_saved = 0;
 
for row_index = 0L, (num_rows - 1) do begin

    ; Look through all columns.  If we find a bad value, mark the index of the row and bail.
    found_bad_value = 0;
    column_index = 0L;

    while (found_bad_value EQ 0 && column_index LT num_columns) do begin

        if (i_geolocation_array[column_index,row_index] LT min_valid_value) || $
           (i_geolocation_array[column_index,row_index] GT max_valid_value) then begin
            
            found_bad_value = 1;

;print, 'min_valid_value ', min_valid_value
;print, 'max_valid_value ', max_valid_value
;print, 'found_bad_value ', found_bad_value
;print, 'i_geolocation_array[column_index,row_index] ', i_geolocation_array[column_index,row_index]
;stop;
            ;
            ; Save the bad fill value once only. 
            ;

            if (l_fill_value_saved EQ 0) then begin
                r_bad_fill_value   = i_geolocation_array[column_index,row_index];
                l_fill_value_saved = 1; 
            endif

;print, i_geolocation_array[column_index,row_index], row_index, column_index, $
;        format='("Bad value = ", F-8.3, " row_index = ", I-4, " column_index = ", I-4)';

            ; Save the row index and increment for next bad value.

            r_bad_scan_lines_array[bad_scan_lines_index++] = row_index;

            ; Keep track of how many bad scan lines found.

            r_num_bad_scan_lines++
        endif else begin

            ; Didn't find it, increment to next column.

            column_index++;
        endelse
    end

    ; If we went through all the columns and did not find a bad value, then the row is a good scan

    if (found_bad_value EQ 0) then begin
        r_good_scan_lines_array[good_scan_lines_index++] = row_index; 
        r_num_good_scan_lines++;
        r_scan_line_flag_array[row_index] = 1;  Which means this scan is good.
    endif

endfor

;print, 'r_num_bad_scan_lines ', r_num_bad_scan_lines

; ---------- Close up shop ---------- 

return, r_status
end
