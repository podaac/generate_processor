;  Copyright 2015, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id$
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

FUNCTION convert_additional_night_netcdf_variables_to_gds2,i_filename,i_out_filename,$
             i_num_lons,$
             i_num_lats,$
             i_convert_to_kelvin, $
             i_num_bad_scan_lines, $
             i_bad_scan_lines_array,$
             i_test_parameter

; Function convert additional NetCDF variables to NetCDF to GDS1 if the data was marked as "Night" or "Mixed".
;
; Assumptions and notes:
;
;   1. Modifications were made in 5/2014 to add more error handlings;
;
;       https://podaac-redmine.jpl.nasa.gov/issues/2349 MODIS Level 2 Combiner and MODIS Level 2P Processing to read supporting attributes
;
;      The steps will be preceded with MODIS_L2P_ERROR_STEP n to allow easy search.
;------------------------------------------------------------------------------------------------

; Load constants.

@modis_data_config.cfg

; Define local variables.

r_status = SUCCESS;

; Set our test parameter based on what's being passed in,
TEST_PARAMETER = "";
if (N_ELEMENTS(i_test_parameter) NE 0) then begin
    TEST_PARAMETER = i_test_parameter;
endif

routine_name = "convert_additional_night_netcdf_variables_to_gds2";
msg_type = "";
msg = ""
i_data = "";

debug_module = 'convert_additional_night_netcdf_variables_to_gds2:';
debug_mode = 0
if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_DEBUG_MODE')) EQ 'TRUE') then begin
    debug_mode = 1;
endif

; A few extra parameters to signify if a particular variable should be written out or not.
; If we cannot read a variable in, we cannot do anything with it including writing it out.

ok_to_write_sst4_flag      = 0;
ok_to_write_bias_sst4_flag = 0;
ok_to_write_stdv_sst4_flag = 0;
ok_to_write_qual_sst4_flag = 0;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Read additional night arrays from HDF file and write to NetCDF file.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

i_variable_short_name = 'sst4';

; Check first to see if the variable exist.  If it does, we will attempt to read it.
; Otherwise, don't try to read it.
variable_exist_flag = is_netcdf_variable_in_file($
                          i_filename,$
                          i_variable_short_name);

if (debug_mode) then begin
print, 'i_filename ', i_filename, ' i_variable_short_name ', i_variable_short_name, ' variable_exist_flag ', variable_exist_flag
endif

; BEGIN_CHECK_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------
if (variable_exist_flag) then begin

r_status = read_gds1_netcdf_one_variable(i_filename,i_variable_short_name,$
               o_data_variable_structure);

ok_to_write_sst4_flag = 1;

if (TEST_PARAMETER EQ "BAD_SST4_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (debug_mode) then begin
    print, 'i_filename ', i_filename, ' i_variable_short_name ', i_variable_short_name, ' variable_exist_flag ', variable_exist_flag, ' TEST_PARAMETER ', TEST_PARAMETER, ' r_status ', r_status
endif

; MODIS_L2P_ERROR_STEP 18: If cannot read optional additional night variable 'sst4' from night file, WARN sigevent thrown, keep going 

if (r_status NE SUCCESS) then begin
    msg_type = "warning";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    donotcare = wrapper_ghrsst_notify_operator($
                    routine_name,$
                    msg_type,$
                    msg,$
                    i_data);
    ok_to_write_sst4_flag = 0;  We won't be doing anything with the sst4 variable.
    ; Keep going
endif; end if ((r_status NE SUCCESS)

if (ok_to_write_sst4_flag) then begin
    r_dataset_array =  *(o_data_variable_structure.s_variable_array);
    PTR_FREE, o_data_variable_structure.s_variable_array;
    r_status = find_netcdf_variable_attribute_info('_FillValue',   o_data_variable_structure.s_attributes_array,r_fill_value);
    r_status = find_netcdf_variable_attribute_info('scale_factor', o_data_variable_structure.s_attributes_array,r_slope);
    r_status = find_netcdf_variable_attribute_info('add_offset',   o_data_variable_structure.s_attributes_array,r_intercept);
    r_status = find_netcdf_variable_attribute_info('valid_min',    o_data_variable_structure.s_attributes_array,r_valid_min);
    r_status = find_netcdf_variable_attribute_info('valid_max',    o_data_variable_structure.s_attributes_array,r_valid_max);
    data_type_as_int = SIZE(r_dataset_array,/TYPE);
    r_data_type = convert_int_type_to_char_type(data_type_as_int);
endif

if (ok_to_write_sst4_flag) then begin
;
; Save the 'sst4' array for later processing.
;

saved_sst4_array = r_dataset_array;

i_dataset_name = 'sea_surface_temperature_4um';
if (strcmp(i_convert_to_kelvin,'yes')) then begin
    i_units = 'kelvin';
    r_intercept += CELSIUS_TO_KELVIN_CONVERSION_FACTOR;
end else begin
    i_units = 'celsius';
endelse

; If the fill value is provided from HDF file, we attempt to use it
if (N_ELEMENTS(r_fill_value)) then begin
    ; Do nothing, the variable r_fill_value is already contained the value we want.
endif else begin
    ; If the fill value is not provided, we use a constant, which is hard-coded.
    r_fill_value = MISSING_VALUE_SST;
endelse

; If the valid_min value is provided from HDF file, we attempt to use it

if (N_ELEMENTS(r_valid_min)) then begin
    ; Do nothing, the variable is already contained the value we want.
endif else begin
    ; If the value is not provided, we use a constant, which is hard-coded.
    r_valid_min = -1000;
endelse

; If the valid_max value is provided from HDF file, we attempt to use it

if (N_ELEMENTS(r_valid_max)) then begin
    ; Do nothing, the variable is already contained the value we want.
endif else begin
    ; If the value is not provided, we use a constant, which is hard-coded.
    r_valid_max = 8000;
endelse

i_coordinates = "lon lat";
i_long_name =  'sea surface temperature';
i_source = 'none';
i_comment = 'sea surface temperature from mid-IR (4 um) channels; non L2P core field';

;l_status = fill_bad_scan_lines_with_missing_value(i_dataset_name,$
;                i_num_bad_scan_lines, $
;                i_bad_scan_lines_array, $
;                r_fill_value, $
;                r_dataset_array);
if (debug_mode) then begin
    print, debug_module + 'Writing ' + i_dataset_name;
endif
    r_status = write_gds2_variable(i_out_filename,$
                                   r_dataset_array,$
                                   i_dataset_name,$
                                   undefined_standard_name,$
                                   i_units,$
                                   r_fill_value,$
                                   r_data_type,$
                                   r_valid_min,$
                                   r_valid_max,$
                                   i_comment,$
                                   i_long_name,$
                                   r_slope,$
                                   r_intercept,$
                                   undefined_source,$
                                   i_coordinates);

    if (TEST_PARAMETER EQ "BAD_SST4_VARIABLE_WRITE") then begin
        r_status = FAILURE;
    endif

    if (r_status EQ FAILURE) then begin
        msg_type = "warning";
        msg = 'Failed in write_gds2_variable:' + i_dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        donotcare = wrapper_ghrsst_notify_operator($
                        routine_name,$
                        msg_type,$
                        msg,$
                        i_data);
        ; Keep going
     endif
endif; end if (ok_to_write_sst4_flag)
endif else begin; end if (variable_exist_flag
    if (debug_mode) then begin
        print, debug_module + 'Variable ' + i_variable_short_name + ' does not exist in file ' + i_filename;
    endif
endelse
; END_CHECK_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------

;--------------------------------------------------------------------------------
; Read bias_sst4 from HDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'bias_sst4';

; Check first to see if the variable exist.  If it does, we will attempt to read it.
; Otherwise, don't try to read it.

variable_exist_flag = is_netcdf_variable_in_file($
                          i_filename,$
                          i_variable_short_name);

; BEGIN_CHECK_BIAS_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------
if (variable_exist_flag) then begin

r_status = read_gds1_netcdf_one_variable(i_filename,i_variable_short_name,$
               o_data_variable_structure);

ok_to_write_bias_sst4_flag = 1;

if (TEST_PARAMETER EQ "BAD_BIAS_SST4_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (debug_mode) then begin
    print, 'i_filename ', i_filename, ' i_variable_short_name ', i_variable_short_name, ' variable_exist_flag ', variable_exist_flag, ' TEST_PARAMETER ', TEST_PARAMETER, ' r_status ', r_status
endif

; MODIS_L2P_ERROR_STEP 19: If cannot read optional additional night variable 'bias_sst4' from night file, WARN sigevent thrown, keep going

if (r_status NE SUCCESS) then begin
    msg_type = "warning";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    donotcare = wrapper_ghrsst_notify_operator($
                    routine_name,$
                    msg_type,$
                    msg,$
                    i_data);
    ok_to_write_bias_sst4_flag = 0;
    ; Keep going
endif
if (ok_to_write_bias_sst4_flag) then begin
    r_bias_sst4 =  *(o_data_variable_structure.s_variable_array);
    PTR_FREE, o_data_variable_structure.s_variable_array;
    r_status = find_netcdf_variable_attribute_info('scale_factor', o_data_variable_structure.s_attributes_array,r_slope_bias_error);
    r_status = find_netcdf_variable_attribute_info('add_offset',   o_data_variable_structure.s_attributes_array,r_intercept_bias_error);
    data_type_as_int = SIZE(r_bias_sst4,/TYPE);
    r_data_type = convert_int_type_to_char_type(data_type_as_int);
endif
endif else begin; end if (variable_exist_flag)
    if (debug_mode) then begin
        print, debug_module + 'Variable ' + i_variable_short_name + ' does not exist in ' + i_filename;
    endif
endelse
; END_CHECK_BIAS_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------

;--------------------------------------------------------------------------------
; Read stdv_sst4 from HDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'stdv_sst4';

; Check first to see if the variable exist.  If it does, we will attempt to read it.
; Otherwise, don't try to read it.
variable_exist_flag = is_netcdf_variable_in_file($
                          i_filename,$
                          i_variable_short_name);

; BEGIN_CHECK_STDV_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------
if (variable_exist_flag) then begin

r_status = read_gds1_netcdf_one_variable(i_filename,i_variable_short_name,$
               o_data_variable_structure);

ok_to_write_stdv_sst4_flag = 1;

if (TEST_PARAMETER EQ "BAD_STDV_SST4_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (debug_mode) then begin
    print, 'i_filename ', i_filename, ' i_variable_short_name ', i_variable_short_name, ' variable_exist_flag ', variable_exist_flag, ' TEST_PARAMETER ', TEST_PARAMETER, ' r_status ', r_status
endif

; MODIS_L2P_ERROR_STEP 20: If cannot read optional additional night variable 'stdv_sst4' from night file, WARN sigevent thrown, keep going 

if (r_status NE SUCCESS) then begin
    msg_type = "warning";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    donotcare = wrapper_ghrsst_notify_operator($
                    routine_name,$
                    msg_type,$
                    msg,$
                    i_data);
    ok_to_write_stdv_sst4_flag = 0;
    ; Keep going
endif

if (ok_to_write_stdv_sst4_flag) then begin
    r_stdv_sst4 =  *(o_data_variable_structure.s_variable_array);
    PTR_FREE, o_data_variable_structure.s_variable_array;
    r_status = find_netcdf_variable_attribute_info('scale_factor', o_data_variable_structure.s_attributes_array,r_slope_standard_deviation_sst);
    r_status = find_netcdf_variable_attribute_info('add_offset',   o_data_variable_structure.s_attributes_array,r_intercept_standard_deviation_sst);
    data_type_as_int = SIZE(r_stdv_sst4,/TYPE);
    r_data_type = convert_int_type_to_char_type(data_type_as_int);
endif
endif else begin; end if (variable_exist_flag)
    if (debug_mode) then begin
        print, debug_module + 'Variable ' + i_variable_short_name + ' does not exist in file ' + i_filename;
    endif
endelse
; END_CHECK_STDV_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------

; Read qual_sst4 from HDF file and write to NetCDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'qual_sst4';

; Check first to see if the variable exist.  If it does, we will attempt to read it.
; Otherwise, don't try to read it.
variable_exist_flag = is_netcdf_variable_in_file($
                          i_filename,$
                          i_variable_short_name);

; BEGIN_CHECK_QUAL_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------
if (variable_exist_flag) then begin

r_status = read_gds1_netcdf_one_variable(i_filename,i_variable_short_name,$
               o_data_variable_structure);

ok_to_write_qual_sst4_flag = 1;

if (TEST_PARAMETER EQ "BAD_QUAL_SST4_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (debug_mode) then begin
    print, 'i_filename ', i_filename, ' i_variable_short_name ', i_variable_short_name, ' variable_exist_flag ', variable_exist_flag, ' TEST_PARAMETER ', TEST_PARAMETER, ' r_status ', r_status
endif

; MODIS_L2P_ERROR_STEP 21: If cannot read optional additional night variable 'qual_sst4'from night file, WARN sigevent thrown, keep going

if (r_status NE SUCCESS) then begin
    msg_type = "warning";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    donotcare = wrapper_ghrsst_notify_operator($
                    routine_name,$
                    msg_type,$
                    msg,$
                    i_data);
    ok_to_write_qual_sst4_flag = 0;
    ; Keep going 
endif

r_qual_sst4 =  *(o_data_variable_structure.s_variable_array);
PTR_FREE, o_data_variable_structure.s_variable_array;
r_status = find_netcdf_variable_attribute_info('scale_factor', o_data_variable_structure.s_attributes_array,r_slope);
r_status = find_netcdf_variable_attribute_info('add_offset',   o_data_variable_structure.s_attributes_array,r_intercept);
data_type_as_int = SIZE(r_qual_sst4,/TYPE);
r_data_type = convert_int_type_to_char_type(data_type_as_int);
endif else begin;
    if (debug_mode) then begin
        print, debug_module + 'Variable ' + i_variable_short_name + ' does not exist in ' + i_filename;
    endif
endelse
; END_CHECK_QUAL_SST4_VARIABLE_EXIST ---------- ---------- ---------- ---------- ---------- ---------- ----------

if ((ok_to_write_sst4_flag) AND (ok_to_write_bias_sst4_flag)) then begin
; Build an array to update the elements with.

; The calculation of the proximity confidence mapping depends on the stdv_sst4 variable being able to be read successfully.
; We only proceed if the variable exists.
if ((ok_to_write_qual_sst4_flag) AND (ok_to_write_stdv_sst4_flag)) then begin
r_updated_qual_sst4 = r_qual_sst4;

if ((ok_to_write_sst4_flag) AND (ok_to_write_bias_sst4_flag)) then begin
status = perform_proximity_confidence_mapping(i_num_lons,i_num_lats,$
             saved_sst4_array,$
             r_qual_sst4,$
             r_bias_sst4,$
             r_stdv_sst4,$
             r_updated_qual_sst4);
endif

i_dataset_name = 'quality_level_4um';
i_units = 'dimensionless';
r_fill_value = BYTE_FILL_VALUE;
i_valid_min = 0B;
i_valid_max = 5B;
i_coordinates = "lon lat";
i_long_name =  'quality level of SST pixel';
i_comment =  "mid-IR SST proximity confidence value; non L2P core field; signed byte array:  WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";
flag_meanings = "no_data bad_data worst_quality low_quality acceptable_quality best_quality";

; The flag_values is an array of 6 elements from 0B to 5B.  We manually set these values.

flag_values = BYTARR(6);
flag_values[0] = 0B;
flag_values[1] = 1B;
flag_values[2] = 2B;
flag_values[3] = 3B;
flag_values[4] = 4B;
flag_values[5] = 5B;

if (debug_mode) then begin
    print, debug_module + 'Writing ' + i_dataset_name;
endif
    r_status = write_gds2_variable(i_out_filename,$
                                   r_updated_qual_sst4,$
                                   i_dataset_name,$
                                   undefined_standard_name,$
                                   undefined_units,$
                                   r_fill_value,$
                                   r_data_type,$
                                   i_valid_min,$
                                   i_valid_max,$
                                   i_comment,$
                                   i_long_name,$
                                   undefined_slope,$
                                   undefined_intercept,$
                                   undefined_source,$
                                   i_coordinates,$
                                   flag_values,$
                                   flag_meanings);

    if (TEST_PARAMETER EQ "BAD_PROXIMITY_CONFIDENCE4_VARIABLE_WRITE") then begin
        r_status = FAILURE;
    endif

    if (r_status EQ FAILURE) then begin
        msg_type = "warning";
        msg = 'Failed in write_gds2_variable:' + i_dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        donotcare = wrapper_ghrsst_notify_operator($
                        routine_name,$
                        msg_type,$
                        msg,$
                        i_data);

        ; Keep going
     endif
endif; end if  (ok_to_write_qual_sst4_flag)
endif; end if ((ok_to_write_sst4_flag) AND (ok_to_write_bias_sst4_flag))

if ((ok_to_write_sst4_flag) AND (ok_to_write_bias_sst4_flag)) then begin
;
; Write the other byte arrays.
;

i_dataset_name = 'sses_bias_4um';
standard_name  = 'sses_bias_4um';
if (i_convert_to_kelvin EQ 'yes') then begin
    i_units = 'kelvin';
end else begin
    i_units = 'celsius';
end

r_fill_value = BYTE_FILL_VALUE;
i_valid_min =  -127B; 
i_valid_max = SIGNED_BYTE_VALID_MAX; place holder
i_coordinates = "lon lat";
i_long_name =  'SSES bias error based on proximity confidence flags';
i_source = 'none';
i_comment =  "mid-IR SST bias error; non L2P core field; signed byte array:  WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";

size_array = size(r_bias_sst4);
num_columns = size_array[1];
num_rows    = size_array[2];
r_bias_sst4_as_int = INTARR(num_columns,num_rows,/NOZERO);

;l_status = fill_bad_scan_lines_with_missing_value(i_dataset_name,$
;                i_num_bad_scan_lines, $
;                i_bad_scan_lines_array, $
;                r_fill_value, $
;                r_bias_sst4);

; If we are not processing from original NetCDF file, use the "converted" intercept value. 
if (GETENV('GHRSST_MODIS_L2P_CONVERTING_FROM_ORIGINAL_NETCDF_FILES') NE 'true') then begin
    l_status = convert_to_signed_byte(r_bias_sst4,r_intercept_bias_error,r_bias_sst4_as_int);
if (debug_mode) then begin
    print, debug_module + 'Writing ' + i_dataset_name;
endif
    r_status = write_gds2_variable(i_out_filename,$
                                   r_bias_sst4_as_int,$
                                   i_dataset_name,$
                                   undefined_standard_name,$
                                   i_units,$
                                   r_fill_value,$
                                   r_data_type,$
                                   i_valid_min,$
                                   i_valid_max,$
                                   i_comment,$
                                   i_long_name,$
                                   r_slope_bias_error,$
                                   r_intercept_bias_error,$
                                   undefined_source,$
                                   i_coordinates);
endif else begin
    ; If we are processing from original NetCDF file, use the different scaling to convert from short to byte and also reset the scale factor and offset.
    scaling_status = apply_scaling_from_short_to_byte($
                         r_slope_bias_error,$
                         r_bias_sst4,$
                         o_byte_variable_array,$
                         o_byte_scale_factor,$
                         o_byte_add_offset);

if (debug_mode) then begin
print, 'Content of original short variable from NetCDF file:'
print, '          r_slope_bias_error          = ', r_slope_bias_error;
print, '          r_intercept_bias_error      = ', r_intercept_bias_error;   
print, 'ORIGINAL  : r_bias_sst4[0,0]           = ', r_bias_sst4[0,0];
print, 'CALCULATED: r_bias_sst4[0,0]*r_slope_bias_error + r_intercept_bias_error = ', r_bias_sst4[0,0] * r_slope_bias_error + r_intercept_bias_error;   
print, ''
print, 'Content of scaled byte variable to be written to NetCDF file:'
print, '          o_byte_scale_factor              = ', o_byte_scale_factor;
print, '          o_byte_add_offset                = ', o_byte_add_offset;   
print, 'ORIGINAL  o_byte_variable_array[0,0]) = ', o_byte_variable_array[0,0]
print, 'CALCULATED:o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset     = ', o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset;
print, 'Writing ' + i_dataset_name;
endif

    o_byte_variable_array = BYTE(o_byte_variable_array);  Do an explit casting otherwise the function write_gds2_variable will fail.
    r_status = write_gds2_variable(i_out_filename,$
                                   o_byte_variable_array,$
                                   i_dataset_name,$
                                   undefined_standard_name,$
                                   i_units,$s
                                   r_fill_value,$
                                   r_data_type,$
                                   i_valid_min,$
                                   i_valid_max,$
                                   i_comment,$
                                   i_long_name,$
                                   o_byte_scale_factor,$
                                   o_byte_add_offset,$
                                   undefined_source,$
                                   i_coordinates);
endelse

    if (TEST_PARAMETER EQ "BAD_BIAS_SST4_VARIABLE_WRITE") then begin
        r_status = FAILURE;
    endif

    if (r_status EQ FAILURE) then begin
        msg_type = "warning";
        msg = 'Failed in write_gds2_variable:' + i_dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        donotcare = wrapper_ghrsst_notify_operator($
                        routine_name,$
                        msg_type,$
                        msg,$
                        i_data);

        ; Keep going
     endif
endif; end if ((ok_to_write_sst4_flag) AND (ok_to_write_bias_sst4_flag))

if (ok_to_write_stdv_sst4_flag) then begin
i_dataset_name = 'sses_standard_deviation_4um';
standard_name  = 'sses_standard_deviation_4um';
if (i_convert_to_kelvin EQ 'yes') then begin
    i_units = 'kelvin';
end else begin
    i_units = 'celsius';
end

r_fill_value = BYTE_FILL_VALUE;
i_valid_min =  -127B; 
i_valid_max = SIGNED_BYTE_VALID_MAX; place holder
i_coordinates = 'lon lat';
i_long_name =  'SSES standard deviation error based on proximity confidence flags';
i_source = 'none';
i_comment =  "mid-IR SST standard deviation error; non L2P core field; signed byte array:  WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";

; Because the variable r_bias_sst4 may not have been read successfully, we get the num_columns and num_rows from variable r_stdv_sst4
size_array = size(r_stdv_sst4);
num_columns = size_array[1];
num_rows    = size_array[2];
r_stdv_sst4_as_int = INTARR(num_columns,num_rows,/NOZERO);

; If we are not processing from original NetCDF file, use the "converted" intercept value. 
if (GETENV('GHRSST_MODIS_L2P_CONVERTING_FROM_ORIGINAL_NETCDF_FILES') NE 'true') then begin
    status = convert_to_signed_byte(r_stdv_sst4,r_intercept_standard_deviation_sst,r_stdv_sst4_as_int);
if (debug_mode) then begin
    print, debug_module + 'Writing ' + i_dataset_name;
endif
    r_status = write_gds2_variable(i_out_filename,$
                                   r_stdv_sst4_as_int,$
                                   i_dataset_name,$
                                   undefined_standard_name,$
                                   i_units,$
                                   r_fill_value,$
                                   r_data_type,$
                                   i_valid_min,$
                                   i_valid_max,$
                                   i_comment,$
                                   i_long_name,$
                                   r_slope_standard_deviation_sst,$
                                   r_intercept_standard_deviation_sst,$
                                   undefined_source,$
                                   i_coordinates);


endif else begin
    ; If we are processing from original NetCDF file, use the different scaling to convert from short to byte and also reset the scale factor and offset.
    scaling_status = apply_scaling_from_short_to_byte_for_stdv_variable($
                         r_slope_standard_deviation_sst,$
                         r_stdv_sst4,$
                         o_byte_variable_array,$
                         o_byte_scale_factor,$
                         o_byte_add_offset);

if (debug_mode) then begin
print, 'Content of original short variable from NetCDF file:'
print, '          r_slope_standard_deviation_sst = ', r_slope_standard_deviation_sst;
print, '          r_intercept_standard_deviation_sst = ', r_intercept_standard_deviation_sst;   
print, 'ORIGINAL  : r_stdv_sst4[0,0]           = ', r_stdv_sst4[0,0];
print, 'CALCULATED: r_stdv_sst4[0,0]*r_slope_bias_error + r_intercept_bias_error = ', r_stdv_sst4[0,0] * r_slope_standard_deviation_sst + r_intercept_standard_deviation_sst;   
print, ''
print, 'Content of scaled byte variable to be written to NetCDF file:'
print, '          o_byte_scale_factor              = ', o_byte_scale_factor;
print, '          o_byte_add_offset                = ', o_byte_add_offset;   
print, 'ORIGINAL  o_byte_variable_array[0,0]) = ', o_byte_variable_array[0,0]
print, 'CALCULATED:o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset     = ', o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset;
print, 'Writing ' + i_dataset_name;
endif

    o_byte_variable_array = BYTE(o_byte_variable_array);  Do an explicit casting otherwise the function write_gds2_variable will fail.
    r_status = write_gds2_variable(i_out_filename,$
                                   o_byte_variable_array,$
                                   i_dataset_name,$
                                   undefined_standard_name,$
                                   i_units,$
                                   r_fill_value,$
                                   r_data_type,$
                                   i_valid_min,$
                                   i_valid_max,$
                                   i_comment,$
                                   i_long_name,$
                                   o_byte_scale_factor,$
                                   o_byte_add_offset,$
                                   undefined_source,$
                                   i_coordinates);
endelse

    if (TEST_PARAMETER EQ "BAD_STANDARD_DEVIATION_ERROR4_VARIABLE_WRITE") then begin
        r_status = FAILURE;
    endif

    if (r_status EQ FAILURE) then begin
        msg_type = "warning";
        msg = 'Failed in write_gds2_variable:' + i_dataset_name + ' to file ' + i_out_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
        donotcare = wrapper_ghrsst_notify_operator($
                        routine_name,$
                        msg_type,$
                        msg,$
                        i_data);

        ; Keep going
     endif
endif; end if (ok_to_write_stdv_sst4_flag)

; ---------- Close up shop ---------- 

return, r_status
end
