;  Copyright 2015, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id$
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

FUNCTION validate_time_field,$
             i_attribute_name,$
             i_attribute_value,$
             o_timestamp_string

; Function validate the time field which is in this format:
;     2006097132007000
;     2006097132506000
;
;     0123456789012345
;     index above
;
; and returns 1 if the field is valid and 0 if not.
; Function also return an optional o_timestamp_string
;
; It uses the TIMESTAMP function to perform the conversion to a valid timestamp.  An exception
; will be thrown and caught if the input the function is invalid.
;
;------------------------------------------------------------------------------------------------

; Load constants.

@modis_data_config.cfg

; Define local variables.

o_time_field_valid_flag = SUCCESS;  Start out assume the the TIMESTAMP conversion is successful.

routine_name = "validate_time_field:";
msg_type = "";
i_data = "";

; Get the DEBUG_MODE if it is set.

debug_module = 'validate_time_field:';
debug_mode = 0
if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_DEBUG_MODE')) EQ 'TRUE') then begin
    debug_mode = 1;
endif

; Do a sanity check to make sure the field is a string.

if ISA(i_attribute_value,/NUMBER) then begin
    print, debug_module + 'ERROR: Expected parameter i_attribute_value to be a string but is a NUMBER.';
    o_time_field_valid_flag = FAILURE;
    return, o_time_field_valid_flag;
endif
 
; Do a sanity check on how many characters are given.
; The minimum is 13 without the 3 digits for the milliseconds.

MINIMUM_CHARACTERS_IN_TIME_ATTRIBUTE_EXPECTED = 13;
if (STRLEN(i_attribute_value) LT MINIMUM_CHARACTERS_IN_TIME_ATTRIBUTE_EXPECTED) then begin
    print, debug_module + 'ERROR: Expected length of input i_attribute_value [' + i_attribute_value + '] to be at least ' + STRTRIM(STRING(MINIMUM_CHARACTERS_IN_TIME_ATTRIBUTE_EXPECTED),2) + ' but received ' + STRTRIM(STRLEN(STRING(i_attribute_value)),2);
    o_time_field_valid_flag = FAILURE;
    return, o_time_field_valid_flag;
endif

; Parse the time for hour, minute, seconds
; Format: 2006097132007000
;         2006097132506000
;
;         0123456789012345

n_year    =  LONG(STRMID(i_attribute_value,0,4));
n_doy     =  LONG(STRMID(i_attribute_value,4,3));

o_time_field_valid_flag = validate_day_of_year_field(n_year,n_doy);

if (o_time_field_valid_flag NE SUCCESS) then begin
    return, o_time_field_valid_flag;
endif

n_hours   = LONG(STRMID(i_attribute_value,7,2));
n_minutes = LONG(STRMID(i_attribute_value,9,2));
n_seconds = LONG(STRMID(i_attribute_value,11,2));

; Save these in gds2 format so we can write them to gds2 format NetCDF file.

c_hours   = STRMID(i_attribute_value,7,2);
c_minutes = STRMID(i_attribute_value,9,2);
c_seconds = STRMID(i_attribute_value,11,2);

;
; Build the date and time for global attribute in output file.
; 

; First, convert the day of year to month and day.

o_status = calday(n_year,$
                  n_doy,$
                  o_month_string,$
                  o_month,$
                  o_monthday); 

CATCH, error_status
if (error_status NE 0) then begin
    print, debug_module,'ERROR, Cannot convert to TIMESTAMP from value ' + i_attribute_value;
    CATCH, /CANCEL
    o_time_field_valid_flag = FAILURE;
    return, o_time_field_valid_flag;
endif

; Attempt to convert to TIMESTAMP.  If it fails, the CATCH clause will be executed above.

o_timestamp_string = TIMESTAMP(YEAR = n_year,  MONTH  = o_month,   DAY    = o_monthday, $
                               HOUR = n_hours, MINUTE = n_minutes, SECOND = n_seconds);

; If we got to here, the TIMESTAMP conversion was successful.

if (debug_mode) then begin
    print, debug_module + 'DEBUG: o_timestamp_string [' + o_timestamp_string + ']'
endif

return, o_time_field_valid_flag;

end
