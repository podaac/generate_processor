;  Copyright 2006, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id: convert_modis_from_hdf_to_netcdf.pro,v 1.32 2007/11/13 16:41:37 qchau Exp $
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CVS

FUNCTION convert_modis_from_hdf_to_netcdf,$
             i_filename,$
             i_out_filename,$
             i_start_time_array_element,$
             i_convert_to_kelvin,$
             i_processing_type,$
             o_day_or_night,$
             i_test_parameter 

; Function convert a MODIS file from HDF format to NetCDF.
;
; Assumptions:
;
;   1. TBD.
;
; October, 2013: Added extra parameter i_test_parameter to allow testing of different fail scenarios.
;                The possible values are defined in the new test script convert_modis_from_hdf_to_netcdf_test.pro
;
;                      "BAD_INPUT_FILE";
;                      "MISSING_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_LONG_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_FLOAT_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_OUTPUT_FILE_CREATION";
;                      "BAD_START_TIME_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_END_TIME_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_SENSOR_NAME_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_START_NODE_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_END_NODE_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_DAY_OR_NIGHT_GLOBAL_ATTRIBUTE_READ";
;                      "BAD_CNTL_PT_COLS_VARIABLE_READ";
;                      "BAD_CNTL_PT_ROWS_VARIABLE_READ";
;                      "BAD_LONGITUDE_VARIABLE_READ";
;                      "BAD_LONGITUDE_SCAN_LINES";
;                      "BAD_LATITUDE_VARIABLE_READ";
;                      "BAD_LATITUDE_SCAN_LINES";
;                      "BAD_SST_VARIABLE_READ";
;                      "BAD_SEA_SURFACE_TEMPERATURE_VARIABLE_WRITE";
;                      "BAD_SST_DTIME_VARIABLE_WRITE";
;                      "BAD_LAT_VARIABLE_WRITE";
;                      "BAD_LON_VARIABLE_WRITE";
;                      "BAD_TIME_VARIABLE_WRITE";

;------------------------------------------------------------------------------------------------

; Load constants.

@modis_data_config.cfg

; Define local variables.

r_status = SUCCESS;

; Define some output variable so if we return quickly, the variable will be defined.

o_day_or_night = 'Day';  Set default to 'Day'.  It will be set to whatever we fetch from the file.

; Set our test parameter based on what's being passed in,
TEST_PARAMETER = "";
if (N_ELEMENTS(i_test_parameter) NE 0) then begin
    TEST_PARAMETER = i_test_parameter;
endif

; Variables for reporting sigevents.

routine_name = "convert_modis_from_hdf_to_netcdf";
msg_type = "";
msg = ""
i_data = "";

; Get the DEBUG_MODE if it is set.

debug_module = 'convert_modis_from_hdf_to_netcdf:';
debug_mode = 0
if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_DEBUG_MODE')) EQ 'TRUE') then begin
    debug_mode = 1;
endif

; MODIS_L2P_ERROR_STEP 1. If the input file does not exist, ERROR sigevent thrown, returns.

; Return if file does not exist.

file_exist = FILE_TEST(i_filename);

if (TEST_PARAMETER EQ "BAD_INPUT_FILE") then begin
    file_exist = 0;
endif

if (file_exist EQ 0) then begin
    r_status = FILE_NOT_FOUND_STATUS;
    msg_type = "error";
    msg = 'Input file not found: ' + i_filename; 
    print, debug_module + msg;
    l_status = error_log_writer(routine_name,msg);
    donotcare = wrapper_ghrsst_notify_operator($
                        routine_name,$
                        msg_type,$
                        msg,$
                        i_data);
    
    return, r_status;
endif

; Get just the file name without the directory.

splitted_string = strsplit(i_filename, "/", /REGEX, /EXTRACT);
num_substrings = SIZE(splitted_string,/N_ELEMENTS);
in_filename_only = splitted_string[num_substrings-1];

; List of LONG global attributes to read from HDF file.

long_attributes_names = [$
                          'Start Year', $
                          'Start Day', $
                          'Start Millisec', $
                          'End Year', $
                          'End Day', $
                          'End Millisec',$
                          'Number of Scan Lines',$
                          'Pixels per Scan Line']

; Array to store these LONG values.  Note that this cannot be used to read character variables.

long_attributes_values = LONARR(size(long_attributes_names,/N_ELEMENTS));

; List of indices to global_variable_values array.

Start_Year_index     = 0;
Start_Day_index      = 1;
Start_Millisec_index = 2;
End_Year_index       = 3;
End_Day_index        = 4;
End_Millisec_index   = 5;
Number_of_Scan_Lines_index = 6;
Pixels_per_Scan_Line_index = 7;

;
; Read all the LONG global attributes.
;

for i = 0, (size(long_attributes_values,/N_ELEMENTS) - 1) do begin

    ; Read one attribute at a time.

    r_status = read_hdf_global_attribute(i_filename,long_attributes_names[i],r_long_attribute_value);

    if (TEST_PARAMETER EQ "MISSING_GLOBAL_ATTRIBUTE") then begin
        r_status = FAILURE;
    endif

    ; MODIS_L2P_ERROR_STEP 2. If global attributes cannot be read, ERROR sigevent thrown, returns.

    if (r_status NE SUCCESS) then begin
        msg_type = "error";
        msg = 'Cannot read long global attribute ' + long_attributes_names[i] + ' from file ' + i_filename; 
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);
    
        r_status = FAILURE;
        ; Must return immediately.
        return, r_status
    endif

    ; Save it in the array.

    long_attributes_values[i] = r_long_attribute_value;

    ; Do a sanity check on these attributes:
    ;                     'Start Year'
    ;                      'Start Day'
    ;                      'Start Millisec'
    ;                      'End Year'
    ;                      'End Day'
    ;                      'End Millisec'

    if (TEST_PARAMETER EQ "BAD_LONG_GLOBAL_ATTRIBUTE") then begin
        long_attributes_values[i] = 0;
    endif

    ; MODIS_L2P_ERROR_STEP 3. If global attributes containing bad value, ERROR sigevent thrown, returns.

    ; Check for zero values for 'Start Year', 'Start Day', 'End Year', and 'End Day':

    if ((((long_attributes_names[i] EQ 'Start Year') OR (long_attributes_names[i] EQ 'Start Day')) OR    $
        ((long_attributes_names[i] EQ 'End Year')    OR (long_attributes_names[i] EQ 'End Day')))  AND  $
        (long_attributes_values[i] EQ 0)) then begin

        msg_type = "error";
        msg = "Cannot read long global attribute " + long_attributes_names[i] + " contains bad value " + STRTRIM(STRING(long_attributes_values[i]),2) + " from file " + i_filename;
        print, debug_module + msg;
        l_status = error_log_writer(routine_name,msg);

        ; No need to keep going.  Exiting now.
        r_status = FAILURE;
        return, r_status;
    endif

    ; Check for negative values for the 'Start Millisec' and 'End Millisec' attributes.  Note that these values can be zero.

    ;Start_Year_index     = 0;
    ;Start_Day_index      = 1;
    ;Start_Millisec_index = 2;
    ;End_Year_index       = 3;
    ;End_Day_index        = 4;
    ;End_Millisec_index   = 5;
    ;Number_of_Scan_Lines_index = 6;
    ;Pixels_per_Scan_Line_index = 7;

    if (TEST_PARAMETER EQ "BAD_LONG_NEGATIVE_START_MILLISEC_GLOBAL_ATTRIBUTE_READ") then begin
        if (i EQ Start_Millisec_index) then long_attributes_values[i] = -1;
    endif
    if (TEST_PARAMETER EQ "BAD_LONG_NEGATIVE_END_MILLISEC_GLOBAL_ATTRIBUTE_READ") then begin
        if (i EQ End_Millisec_index) then long_attributes_values[i] = -1;
    endif

    if (((long_attributes_names[i] EQ 'Start Millisec') OR (long_attributes_names[i] EQ 'End Millisec'))  AND  $
        (long_attributes_values[i] LT 0)) then begin

        msg_type = "error";
        msg = "Cannot read long global attribute " + long_attributes_names[i] + " contains negative value " + STRTRIM(STRING(long_attributes_values[i]),2) + " from file " + i_filename;
        print, debug_module + msg;
        l_status = error_log_writer(routine_name,msg);

        ; No need to keep going.  Exiting now.
        r_status = FAILURE;
        return, r_status;
    endif
endfor

;
; Save most used global attributes.
;

num_lons = long_attributes_values[Number_of_Scan_Lines_index];
num_lats = long_attributes_values[Pixels_per_Scan_Line_index];

;
; List of FLOAT global attributes to read from HDF file.
;

float_attributes_names = ['Northernmost Latitude',$
                          'Southernmost Latitude',$
                          'Easternmost Longitude',$
                          'Westernmost Longitude'];

; List of indices to float_attributes_names array.

Northernmost_Latitude_index = 0;
Southernmost_Latitude_index = 1;
Easternmost_Longitude_index = 2; 
Westernmost_Longitude_index = 3;

; Array to store these FLOAT values.  Note that this cannot be used to read character variables.

float_attributes_values = FLTARR(size(float_attributes_names,/N_ELEMENTS));

;
; Read all the FLOAT global attributes.
;

;print, 'float_attributes_values: ';
for i = 0, (size(float_attributes_values,/N_ELEMENTS) - 1) do begin

    ; Read one attribute at a time.
    r_status = read_hdf_global_attribute(i_filename,float_attributes_names[i],r_float_attribute_value);

    if (TEST_PARAMETER EQ "BAD_FLOAT_GLOBAL_ATTRIBUTE_READ") then begin
        r_status = FAILURE;
    endif

    ; MODIS_L2P_ERROR_STEP 4. If bounding box cannot be read, ERROR sigevent thrown, returns.

    if (r_status NE SUCCESS) then begin
        status = FAILURE;
        msg_type = "error";
        msg = "Cannot read float global attribute " + float_attributes_names[i] + " from file " + i_filename;
        print, debug_module + msg;
        donotcare = error_log_writer(routine_name,msg);

        ; Must return immediately.
        return, status
    endif

    ; Save it.
    float_attributes_values[i] = r_float_attribute_value;

endfor

;
; Read the start time and end time as strings.  Must convert them to seconds.
;
attribute_name = 'Start Time';
r_status = read_hdf_global_attribute(i_filename,attribute_name,r_start_time);

if (TEST_PARAMETER EQ "BAD_START_TIME_GLOBAL_ATTRIBUTE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg_type = 'error';
    msg = 'Cannot read string global attribute ' + attribute_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    return, r_status
endif

attribute_name = 'End Time';
r_status = read_hdf_global_attribute(i_filename,attribute_name,r_end_time);
if (TEST_PARAMETER EQ "BAD_END_TIME_GLOBAL_ATTRIBUTE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot read string global attribute ' + attribute_name + ' from file ' + i_filename;
    print, debug_module + msg
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    return, r_status
endif

start_seconds = long_attributes_values[Start_Millisec_index] / 1000.0;
end_seconds   = long_attributes_values[End_Millisec_index] / 1000.0;

;print, 'start_seconds = ', start_seconds;
;print, 'end_seconds   = ', end_seconds;

; Parse the start time for hour, minute, seconds
; Format: 2006097132007000
;         2006097132506000

;         01234567890

n_hours   = LONG(STRMID(r_start_time,7,2));
n_minutes = LONG(STRMID(r_start_time,9,2));
n_seconds = LONG(STRMID(r_start_time,11,2));

c_hours   = STRMID(r_start_time,7,2);
c_minutes = STRMID(r_start_time,9,2);
c_seconds = STRMID(r_start_time,11,2);

;print, 'n_hours   = ', n_hours;
;print, 'n_minutes = ', n_minutes;
;print, 'n_seconds = ', n_seconds;

;
; Build the start date and time for global attribute in output file.
; 

; First, convert the day of year to month and day.

r_status = calday(long_attributes_values[Start_Year_index],$
                long_attributes_values[Start_Day_index],$
                r_month_string,r_month,r_monthday); 

l_global_start_date_utc =  STRING(long_attributes_values[Start_Year_index],$
                                  r_month, $
                                  r_monthday,$
                                  FORMAT='(I4,"-",I02,"-",I02," UTC")');
l_global_start_time_utc = c_hours + ':' + c_minutes + ':' + c_seconds + ' UTC';

;
; Convert the time the data was first sample to seconds since 1981.  For now, add the
; 33 accummulated leap seconds to the end time. 
;

r_status = get_seconds_since_1981($
             long_attributes_values[Start_Year_index],$
             long_attributes_values[Start_Day_index],$
             n_hours,$
             n_minutes,$
             n_seconds,$
             r_seconds_since_1981);

;print, 'r_seconds_since_1981 = ', r_seconds_since_1981;

; Parse the r_end_time for hour, minute, seconds
; Format: 2006097132007000
;         2006097132506000

;         01234567890

n_hours   = LONG(STRMID(r_end_time,7,2));
n_minutes = LONG(STRMID(r_end_time,9,2));
n_seconds = LONG(STRMID(r_end_time,11,2));

c_hours   = STRMID(r_end_time,7,2);
c_minutes = STRMID(r_end_time,9,2);
c_seconds = STRMID(r_end_time,11,2);

;print, 'n_hours   = ', n_hours;
;print, 'n_minutes = ', n_minutes;
;print, 'n_seconds = ', n_seconds;

;
; Build the start date and time for global attribute in output file. 
; 

; First, convert the day of year to month and day.

r_status = calday(long_attributes_values[End_Year_index],$
                  long_attributes_values[End_Day_index],$
                  r_month_string,r_month,r_monthday); 

l_global_stop_date_utc =  STRING(long_attributes_values[End_Year_index],$
                                 r_month,$
                                 r_monthday,$
                                 FORMAT='(I4,"-",I02,"-",I02," UTC")');
l_global_stop_time_utc = c_hours + ':' + c_minutes + ':' + c_seconds + ' UTC';

;
; Read other character attributes.
;
attribute_name = 'Sensor Name';
r_status = read_hdf_global_attribute(i_filename,attribute_name,r_sensor_name);
if (TEST_PARAMETER EQ "BAD_SENSOR_NAME_GLOBAL_ATTRIBUTE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot read string global attribute ' + attribute_name + ' from file ' + i_filename;
    print, debug_module + msg
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    return, r_status
endif

;print, 'r_sensor_name = ', r_sensor_name;

attribute_name = 'Start Node';
r_status = read_hdf_global_attribute(i_filename,attribute_name,r_start_node);
if (TEST_PARAMETER EQ "BAD_START_NODE_GLOBAL_ATTRIBUTE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot read string global attribute ' + attribute_name + ' from file ' + i_filename;
    print, debug_module + msg
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    return, r_status
endif

;print, 'r_start_node = ', r_start_node;

attribute_name = 'End Node';
r_status = read_hdf_global_attribute(i_filename,attribute_name,r_end_node);
if (TEST_PARAMETER EQ "BAD_END_NODE_GLOBAL_ATTRIBUTE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot read string global attribute ' + attribute_name + ' from file ' + i_filename;
    print, debug_module + msg
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    return, r_status
endif

;print, 'r_end_node = ', r_end_node;

attribute_name = 'Day or Night';
r_status = read_hdf_global_attribute(i_filename,attribute_name,r_day_or_night);
if (TEST_PARAMETER EQ "BAD_DAY_OR_NIGHT_GLOBAL_ATTRIBUTE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot read string global attribute ' + attribute_name + ' from file ' + i_filename;
    print, debug_module + msg
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    return, r_status
endif

; Remove the non-ascii character from variable.

r_day_or_night = convert_to_ascii_string(r_day_or_night);

;print, 'r_day_or_night = [', r_day_or_night,']';
;print, 'strlen = ', strlen(r_day_or_night);
; The value of r_day_or_night are: Night, Day, or Mixed.  We save it in o_day_or_night to return to callee
o_day_or_night = r_day_or_night;

;
; Set attributes to be used as global attributes in output file.
;

l_sensor_name = '';
l_platform = '';
l_title    = '';
l_dsd_entry_id = '';

; Prepend a pre-existing.

l_warning = "; WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";
l_comment = const_comment + "; " + r_day_or_night + ', Start Node:' + r_start_node + ', End Node:' $
                                 + r_end_node + l_warning;

if ((r_sensor_name EQ 'MODISA') OR (r_sensor_name EQ 'HMODISA')) then begin
    l_sensor_name = 'MODIS_A';
    l_platform = 'Aqua';
    l_title    = 'MODIS Aqua L2P SST';
endif else begin
    if ((r_sensor_name EQ 'MODIST') OR (r_sensor_name EQ 'HMODIST')) then begin
        l_sensor_name = 'MODIS_T';
        l_platform = 'Terra';
        l_title    = 'MODIS Terra L2P SST';
    endif
endelse

; Note from 5/2014:
;
; The NetCDF file for test files from 2007 has the r_sensor_name value as 'MODIS'
; We have to determine if it is Aqua or Terra from the first character of the name.

if (l_title EQ '') then begin
    ; Get the name only
    name_only = FILE_BASENAME(i_filename);
    ; The refined files has this /some_directory/refined_A2007079195500.LAC_GSSTD so we may need to skip "refined_" to get to the A letter.
    ;                                            01234567890
    ;
    first_character = STRMID(name_only,0,1);
    if (STRPOS(name_only,'refined_') EQ 0) then begin
        first_character = STRMID(name_only,8,1);  Skip the "refined_" to get to letter A.
    endif
    if (first_character EQ 'A') then begin
        l_sensor_name = 'MODIS_A';
        l_platform = 'Aqua';
        l_title    = 'MODIS Aqua L2P SST';
    endif

    if (first_character EQ 'T') then begin
        l_sensor_name = 'MODIS_T';
        l_platform = 'Terra';
        l_title    = 'MODIS Terra L2P SST';
    endif
endif

l_dsd_entry_id = 'JPL-L2P-' + l_sensor_name;

;
; Create a NetCDF output file.
;

; BEGIN_BLOCK_0
EXECUTE_THIS_BLOCK = 1;

if (EXECUTE_THIS_BLOCK EQ 1) then begin
r_status = create_modis_cdf_file(i_out_filename,$
                               i_start_time_array_element,$
                               l_global_start_date_utc,$
                               l_global_start_time_utc,$
                               l_global_stop_date_utc,$
                               l_global_stop_time_utc,$
                               float_attributes_values[Northernmost_Latitude_index],$
                               float_attributes_values[Southernmost_Latitude_index],$
                               float_attributes_values[Easternmost_Longitude_index],$
                               float_attributes_values[Westernmost_Longitude_index],$
                               long_attributes_values[Pixels_per_Scan_Line_index],$
                               long_attributes_values[Number_of_Scan_Lines_index],$
                               l_title,$
                               l_dsd_entry_id,$
                               l_platform,$
                               l_comment,$
                               i_processing_type);

if (TEST_PARAMETER EQ "BAD_OUTPUT_FILE_CREATION") then begin
        r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 5: If the output file cannot be created, ERROR sigevent thrown, returns.

if (r_status NE SUCCESS) then begin
    status = FAILURE;
    msg_type = "error";
    msg = "Cannot create output file " + i_out_filename;
    print, debug_module + msg;
    l_status = error_log_writer(routine_name,msg);

    ; If the file exist, even though the status is FAILURE, we need to delete it.
    if FILE_TEST(i_out_filename) then begin
        print, debug_module + 'FILE_DELETE ' + i_out_filename;
        FILE_DELETE, i_out_filename, /QUIET;
    endif

    ; Must return immediately.
    return, status
endif

; END_BLOCK_0
endif

;--------------------------------------------------------------------------------
; Read cntl_pt_cols & cntl_pt_rows file and write to NetCDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'cntl_pt_cols';

r_status = read_control_points_variable(i_filename,i_variable_short_name,$
               r_controlled_point_cols,r_long_name,$
               r_units,r_data_type);

if (TEST_PARAMETER EQ "BAD_CNTL_PT_COLS_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

i_variable_short_name = 'cntl_pt_rows'; Should be 2030

r_status = read_control_points_variable(i_filename,i_variable_short_name,$
               r_controlled_point_rows,r_long_name,$
               r_units,r_data_type);

if (TEST_PARAMETER EQ "BAD_CNTL_PT_ROWS_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

i_variable_short_name = 'l2_flags';
r_status = read_hdf_l2_flag_variable(i_filename,$
               i_variable_short_name,$
               r_dataset_array,$
               r_units,$
               r_data_type);

if (TEST_PARAMETER EQ "BAD_L2_FLAGS_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (r_status NE SUCCESS) then begin
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

;
; Use the unmask() function written by BA Franz, Applied Research Corp, 1991
; to extract the 32-bit integer arrays.

r_status = unmask(r_dataset_array, $
                 r_mask_array);

;help, r_mask_array;

; Get just the LAND flag:
;
; Set no 22: Rank: 2, 2040 x 1354
;    Data set name: 'l2_flags'
;    Data type: 32-bit integer
;
;SDS attributes
;    Number of attributes: 34
;        long_name:    Level-2 Processing Flags
;        units:    dimensionless
;        f01_name:    ATMFAIL
;        f02_name:    LAND
;        f03_name:    BADANC

; The LAND index is 1 of the r_mask_array, which is BYTE = Array[32,2748620];

l_land_mask_array = r_mask_array[1,*];

; Get the indices where the land occurs.

l_land_indices  = where (l_land_mask_array EQ 1B,num_land_indices);

i_variable_short_name = 'longitude'; Should be 170 by 2030

r_status = read_control_points_variable(i_filename,i_variable_short_name,$
               r_longitude_subintervals,r_long_name,$
               r_units,r_lon_data_type,r_lon_fill_value);

if (TEST_PARAMETER EQ "BAD_LONGITUDE_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 6: If longitude variable cannot be read, ERROR sigevent thrown, returns.

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot read variable longitude from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    return, r_status;
endif

;
; Identify the bad scan lines in the r_longitude_subintervals array.
;

l_status = identify_bad_scan_lines($
             r_longitude_subintervals,$
             i_variable_short_name,$
             r_good_scan_lines_array,$
             r_num_good_scan_lines,$
             r_bad_scan_lines_array,$
             r_num_bad_scan_lines, $
             r_bad_longitude_fill_value, $
             r_scan_line_flag_array);

if (TEST_PARAMETER EQ "BAD_LONGITUDE_SCAN_LINES") then begin
    r_num_bad_scan_lines = 1;
endif

; MODIS_L2P_ERROR_STEP 7: Identify bad scan lines in longitude, if found at least one, WARN sigevent thrown, keep going.

if (r_num_bad_scan_lines GT 0) then begin
    msg_type = "warning";
    msg = 'File ' + i_filename + ' contains bad longitudes.';
    print, debug_module + msg;
    if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_THROW_WARNING_FOR_BAD_GEOGRAPHIC_COORDINATES')) EQ 'TRUE') then begin
        donotcare = wrapper_ghrsst_notify_operator(routine_name,msg_type,msg,i_data);
    endif
    ; Keep going

    ; Because some 2002 re-processed files may have the _FillValue as -32767.0 but the actual fill value is -999.0, we must
    ; make a correction in subintervals by replacing the -999.0 with -32767.0 everywhere.

    if (N_ELEMENTS(r_lon_fill_value)) then begin
      if (r_lon_fill_value[0] NE r_bad_longitude_fill_value) then begin
        i_array_name = 'longitude';
        i_fill_value = r_lon_fill_value[0];
        correct_status = correct_bad_scan_lines_with_good_missing_values(i_array_name,$
                             r_num_bad_scan_lines,$
                             r_scan_line_flag_array,$
                             i_fill_value,$
                             r_longitude_subintervals);
      endif
    endif
endif

; Print the r_fill_value
if (debug_mode) then begin
    ; Be careful to only print if the variable is defined.
    if (N_ELEMENTS(r_lon_fill_value)) then begin
        print, debug_module + ' filename ' + i_filename + 'longitude:r_lon_fill_value = ', r_lon_fill_value
    endif
endif

;
; Read the latitude subintervals.
;

i_variable_short_name = 'latitude'; Should be 170 by 2030

r_status = read_control_points_variable(i_filename,i_variable_short_name,$
                           r_latitude_subintervals, r_long_name,$
                           r_units,r_lat_data_type,r_lat_fill_value);

if (TEST_PARAMETER EQ "BAD_LATITUDE_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 8: If latitude variable cannot be read, ERROR sigevent thrown, returns.

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    return, r_status;
endif

;
; Identify the bad scan lines in the latitude to retrieve the r_bad_latitude_fill_value.
; This is not necessary since if there are errors in the longitude
; there will be the same number of bad scan lines in the latitude array.
; This function is not necessary if it does not matter what value we fill the latitude array with
; for bad scan lines.
;

l_status = identify_bad_scan_lines($
             r_latitude_subintervals,$
             i_variable_short_name,$
             r_good_scan_lines_array,$
             r_num_good_scan_lines,$
             r_bad_scan_lines_array,$
             r_num_bad_scan_lines, $
             r_bad_latitude_fill_value, $
             r_scan_line_flag_array);

if (TEST_PARAMETER EQ "BAD_LATITUDE_SCAN_LINES") then begin
    r_num_bad_scan_lines = 1;
endif

; MODIS_L2P_ERROR_STEP 9: Identify bad scan lines in latitude, if found at least one, WARN sigevent thrown, keep going.

if (r_num_bad_scan_lines GT 0) then begin
    msg_type = "warning";
    msg = 'File ' + i_filename + ' contains bad latitudes.';
    print, debug_module + msg;
    if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_THROW_WARNING_FOR_BAD_GEOGRAPHIC_COORDINATES')) EQ 'TRUE') then begin
        donotcare = wrapper_ghrsst_notify_operator(routine_name,msg_type,msg,i_data);
    endif

   ; Keep going;

    ; Because some 2002 re-processed files may have the _FillValue as -32767.0 but the actual fill value is -999.0, we must
    ; make a correction in the subintervals by replacing the -999.0 with -32767.0 everywhere.

    if (N_ELEMENTS(r_lat_fill_value)) then begin
      if (r_lat_fill_value[0] NE r_bad_latitude_fill_value) then begin
        i_array_name = 'latitude';
        i_fill_value = r_lat_fill_value[0];
        correct_status = correct_bad_scan_lines_with_good_missing_values(i_array_name,$
                             r_num_bad_scan_lines,$
                             r_scan_line_flag_array,$
                             i_fill_value,$
                             r_latitude_subintervals);
      endif
    endif
endif


; Print the r_fill_value
if (debug_mode) then begin
    ; Be careful to only print if the variable is defined.
    if (N_ELEMENTS(r_lat_fill_value)) then begin
        print, routine_name, ' filename ', i_filename, ' latitude:r_lat_fill_value = ', r_lat_fill_value
    endif
endif

; 
; Remove any dateline discontinuity in the longitudes.
; 

r_dateline_crossed = 0;
size_array = size(r_controlled_point_cols);
num_lat_control_point_cols = size_array[1];   The size of the array is the 2nd element.

l_status = remove_dateline_discontinuity(num_lat_control_point_cols, $
                                         num_lons, $
                                         r_scan_line_flag_array, $
                                         r_longitude_subintervals, $
                                         r_dateline_crossed, $
                                         r_num_longitudes_added, $
                                         r_num_longitudes_subtracted);

;
; If there are no bad scan lines:
;
; perform the spline fit funtions in the longitude direction of the l_longitude_array and
; r_latitude_array using the r_controlled_point_cols, the r_latitude_subintervals and 
; r_longitude_subintervals arrays.
;

l_status = perform_spline_fit_on_controlled_points( $
             r_num_bad_scan_lines, $
             r_scan_line_flag_array, $
             r_bad_longitude_fill_value, $
             r_bad_latitude_fill_value, $
             num_lons, $
             num_lats, $
             r_longitude_subintervals, $
             r_latitude_subintervals, $
             r_controlled_point_cols, $
             i_filename, $
             i_out_filename, $
             l_longitude_array, $
             l_latitude_array);

;
; Convert l_longitude_array array back to [-180,180] coordinate system
; if date line was crossed.
;

if (r_dateline_crossed EQ 1) then begin
    r_status = convert_to_negative_180_positive_180($
                 num_lats,$
                 num_lons,$
                 r_scan_line_flag_array, $
                 l_longitude_array,$
                 r_num_longitudes_added,$
                 r_num_longitudes_subtracted);
endif

;
; Write the lat & lon arrays to NetCDF file.
;

i_dataset_name = 'lat';
i_long_name    = 'latitude';
r_data_type = 'FLOAT';
i_unit      = "degrees_north";

; If the variable r_lat_fill_value was not defined from the file, we use the hard-code default
if (~(N_ELEMENTS(r_lat_fill_value))) then begin
    r_lat_fill_value = r_bad_latitude_fill_value;
endif

;help, r_lat_fill_value;
;help, r_lat_fill_value[0];
;help, r_bad_latitude_fill_value;
;stop;

r_status = write_modis_lat_lon_variable(i_out_filename,$
                                   l_latitude_array,$
                                   i_dataset_name,i_long_name,$
                                   i_unit,$
                                   r_lat_fill_value,$
                                   r_data_type);

if (TEST_PARAMETER EQ "BAD_LAT_VARIABLE_WRITE") then begin
    r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 10: If cannot write 'lat' variable, ERROR sigevent thrown, returns.

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Failed in write_modis_lat_lon_variable:' + i_dataset_name + ' to file ' + i_out_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

i_dataset_name = 'lon';
i_long_name    = 'longitude';
r_data_type = 'FLOAT';
i_unit      = "degrees_east";

; If the variable r_lon_fill_value was not defined from the file, we use the hard-code default
if (~(N_ELEMENTS(r_lon_fill_value))) then begin
    r_lon_fill_value = r_bad_longitude_fill_value;
endif

r_status = write_modis_lat_lon_variable(i_out_filename,$
                                   l_longitude_array,$
                                   i_dataset_name,i_long_name,$
                                   i_unit,$
                                   r_lon_fill_value,$
                                   r_data_type);

;help, r_lon_fill_value;
;print, r_lon_fill_value
;help, r_lon_fill_value[0];
;help, r_bad_longitude_fill_value;
;stop;


if (TEST_PARAMETER EQ "BAD_LON_VARIABLE_WRITE") then begin
    r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 11: If cannot write 'lon' variable, ERROR sigevent thrown, returns.

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot write variable ' + i_dataset_name + ' to file ' + i_out_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Read arrays from HDF file and write to NetCDF file.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; BEGIN_BLOCK_2
EXECUTE_THIS_BLOCK = 1;

if (EXECUTE_THIS_BLOCK EQ 1) then begin
time_array = LONARR(1);
time_array[0] = r_seconds_since_1981;
r_data_type = 'LONG';
i_unit      = 'seconds since 1981-01-01 00:00:00';
i_long_name =  'reference time of sst file'; 
i_dataset_name = 'time';
r_status = write_netcdf_variable(i_out_filename,$
                                   time_array,$
                                   'time',$
                                   r_data_type,$
                                   i_unit,$
                                   i_long_name);

if (TEST_PARAMETER EQ "BAD_TIME_VARIABLE_WRITE") then begin
    r_status = FAILURE;
endif

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot write variable ' + i_dataset_name + ' to file ' + i_out_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

i_variable_short_name = 'sst';

r_status = read_hdf_variable(i_filename,i_variable_short_name,$
                           r_dataset_array, r_slope,$
                           r_intercept,r_data_type,r_sst_fill_value,r_valid_min,r_valid_max);

if (TEST_PARAMETER EQ "BAD_SST_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 12: If cannot read 'sst' variable, ERROR sigevent thrown, returns.

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

;
; Save the 'sst' array for later processing.
;

saved_sst_array = r_dataset_array;

i_dataset_name = 'sea_surface_temperature';

if (strcmp(i_convert_to_kelvin,'yes')) then begin
    i_units = 'kelvin';
    r_intercept += CELSIUS_TO_KELVIN_CONVERSION_FACTOR;
end else begin
    i_units = 'celsius';
end

; If the fill value is provided from HDF file, we attempt to use it
if (N_ELEMENTS(r_sst_fill_value)) then begin
    ; Do nothing, the variable r_fill_value is already contained the value we want.
endif else begin
    ; If the fill value is not provided, we use a constant, which is hard-coded.
    r_sst_fill_value = MISSING_VALUE_SST;
endelse

; If the valid_min value is provided from HDF file, we attempt to use it

if (N_ELEMENTS(r_valid_min)) then begin
    ; Do nothing, the variable is already contained the value we want.
endif else begin
    ; If the value is not provided, we use a constant, which is hard-coded.
    r_valid_min = -1000;
endelse

; If the valid_max value is provided from HDF file, we attempt to use it

if (N_ELEMENTS(r_valid_max)) then begin
    ; Do nothing, the variable is already contained the value we want.
endif else begin
    ; If the value is not provided, we use a constant, which is hard-coded.
    r_valid_max = 8000;
endelse

i_coordinates = "lon lat";
i_long_name =  'sea surface temperature'; 
i_source = 'NASA and University of Miami';
i_comment = 'sea surface temperature from thermal IR (11 um) channels';

r_status = write_modis_data_variable(i_out_filename,$
                                   r_dataset_array,$
                                   i_dataset_name,$
                                   i_long_name,$
                                   i_units,$
                                   r_slope,r_intercept,$
                                   r_sst_fill_value,r_data_type,$
                                   r_valid_min,r_valid_max,i_coordinates,i_source,i_comment);

if (TEST_PARAMETER EQ "BAD_SEA_SURFACE_TEMPERATURE_VARIABLE_WRITE") then begin
    r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 13: If cannot write 'sea_surface_temperature', ERROR sigevent thrown, returns.

if (r_status EQ FAILURE) then begin
;    l_status = error_log_writer('convert_modis_from_hdf_to_netcdf','Failed in write_modis_data_variable:' + i_dataset_name);
    msg_type = "error";
    msg = 'Cannot write variable ' + i_dataset_name + ' to file ' + i_out_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif


; END_BLOCK_2
endif

;--------------------------------------------------------------------------------
; Read msec HDF file and write to NetCDF file.
;--------------------------------------------------------------------------------

; BEGIN_BLOCK_3
EXECUTE_THIS_BLOCK = 1; 

if (EXECUTE_THIS_BLOCK EQ 1) then begin

i_variable_short_name = 'msec';

r_status = read_one_dim_hdf_variable(i_filename,i_variable_short_name,$
                           r_dataset_array, r_units,$
                           r_data_type);

if (TEST_PARAMETER EQ "BAD_MSEC_VARIABLE_READ") then begin
    r_status = FAILURE;
endif

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

;  Convert to seconds first, then subtract each value from the reference time.

r_dataset_array = (r_dataset_array / 1000.0) - start_seconds;

; Create a 2 dimensional array and duplicate each value across all columns.

dtime_array = INTARR(long_attributes_values[Pixels_per_Scan_Line_index],$
                     long_attributes_values[Number_of_Scan_Lines_index]);
;help,dtime_array;

;print, 'convert_modis_from_hdf_to_netcdf:Filling dtime_array....'

; Old and in-efficient method of assigning variable values.

;for i = 0,  (long_attributes_values[Pixels_per_Scan_Line_index] - 1) do begin
;    for j = 0,  (long_attributes_values[Number_of_Scan_Lines_index] - 1) do begin
;         dtime_array[i,j] = r_dataset_array[j]; 
;    endfor 
;endfor 

; Since IDL is efficient with array assignments, we take advantage of it to
; assign the 2nd dimension with dtime_array[i,*] = r_dataset_array[*].

for i = 0,  (long_attributes_values[Pixels_per_Scan_Line_index] - 1) do begin
    dtime_array[i,*] = r_dataset_array[*]; 
endfor 

;
; Write the dtime_array to NetCDF file.
;

i_dataset_name = 'sst_dtime';
i_units = 'second';
r_data_type = 'SHORT';
r_slope = 1.0;
r_intercept = 0.0;
r_fill_value = -32768;
i_valid_min = -32767;
i_valid_max =  32767;
i_long_name = 'time difference from reference time';

r_status = write_modis_data_variable(i_out_filename,$
                                   dtime_array,$
                                   i_dataset_name,$
                                   i_long_name,$
                                   i_units,$
                                   r_slope,r_intercept,$
                                   r_fill_value,r_data_type,$
                                   i_valid_min,i_valid_max,i_coordinates);

if (TEST_PARAMETER EQ "BAD_SST_DTIME_VARIABLE_WRITE") then begin
    r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 14: If cannot write 'sst_dtime' variable, ERROR sigevent thrown, returns.

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot write variable ' + i_dataset_name + ' to file ' + i_out_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

endif
; END_BLOCK_3


; BEGIN_BLOCK_4
EXECUTE_THIS_BLOCK = 1; 

if (EXECUTE_THIS_BLOCK EQ 1) then begin

;--------------------------------------------------------------------------------
; Read bias_sst from HDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'bias_sst';

r_status = read_hdf_variable(i_filename,i_variable_short_name,$
                           r_bias_sst, r_slope_bias_error,$
                           r_intercept_bias_error,r_data_type);

if (TEST_PARAMETER EQ "BAD_BIAS_SST_VARIABLE_READ") then begin
     r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 15: If cannot read 'bias_sst' variable, ERROR sigevent thrown, returns.

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

;--------------------------------------------------------------------------------
; Read stdv_sst from HDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'stdv_sst';

r_status = read_hdf_variable(i_filename,i_variable_short_name,$
                           r_stdv_sst, r_slope_standard_deviation_sst,$
                           r_intercept_standard_deviation_sst,r_data_type);

if (TEST_PARAMETER EQ "BAD_STDV_SST_VARIABLE_READ") then begin
     r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 16: If cannot read 'stdv_sst' variable, ERROR sigevent thrown, returns.

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

;--------------------------------------------------------------------------------
; Read qual_sst from HDF file and write to NetCDF file.
;--------------------------------------------------------------------------------


i_variable_short_name = 'qual_sst';

r_status = read_hdf_variable(i_filename,i_variable_short_name,$
                           r_qual_sst, r_slope,$
                           r_intercept,r_data_type);
if (TEST_PARAMETER EQ "BAD_QUAL_SST_VARIABLE_READ") then begin
     r_status = FAILURE;
endif

; MODIS_L2P_ERROR_STEP 17: If cannot read 'qual_sst' variable, ERROR sigevent thrown, returns.

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

; Build an array to update the elements with.

if (SIZE(r_qual_sst,/N_ELEMENTS) GT 0) then begin
r_updated_qual_sst = r_qual_sst;

r_status = perform_proximity_confidence_mapping(num_lons, num_lats,$
             saved_sst_array,$
             r_qual_sst,$
             r_bias_sst,$
             r_stdv_sst,$
             r_updated_qual_sst);

i_dataset_name = 'proximity_confidence';
i_units = 'dimensionless';
r_fill_value = BYTE_FILL_VALUE;  
i_valid_min = 0B;
i_valid_max = 6B;
i_coordinates = "lon lat";
i_long_name =  'proximity confidence value';
i_source = ''; 
i_comment = "thermal IR SST proximity confidence value; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";
r_status = write_modis_data_variable(i_out_filename,$
                                   r_updated_qual_sst,$
                                   i_dataset_name,$
                                   i_long_name,$
                                   i_units,$
                                   r_slope,r_intercept,$
                                   r_fill_value,r_data_type,$
                                   i_valid_min,i_valid_max,i_coordinates,i_source,i_comment);

if (TEST_PARAMETER EQ "BAD_PROXIMITY_CONFIDENCE_VARIABLE_WRITE") then begin
     r_status = FAILURE;
endif
if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot write variable ' + i_dataset_name + ' to file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

endif

if ((SIZE(r_bias_sst,/N_ELEMENTS)) GT 0) then begin
;
; Write the other byte arrays.
;

i_dataset_name = 'SSES_bias_error';
if (strcmp(i_convert_to_kelvin,'yes')) then begin
    i_units = 'kelvin';
end else begin
    i_units = 'celsius';
end
r_fill_value = BYTE_FILL_VALUE;
i_valid_min = -127B;
i_valid_max = SIGNED_BYTE_VALID_MAX; place holder
i_coordinates = "lon lat";
i_long_name =  'SSES bias error based on proximity confidence flags';
i_source = ''; 
i_comment = "thermal IR SST bias error; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";

; Must allocate an integer array to convert from unsigned byte to signed byte.
size_array = size(r_bias_sst);
num_columns = size_array[1];
num_rows    = size_array[2];
r_bias_sst_as_int = INTARR(num_columns,num_rows,/NOZERO);

; If we are not processing from original NetCDF file, use the "converted" intercept value. 
if (GETENV('GHRSST_MODIS_L2P_CONVERTING_FROM_ORIGINAL_NETCDF_FILES') NE 'true') then begin
    l_status = convert_to_signed_byte(r_bias_sst,r_intercept_bias_error,r_bias_sst_as_int);
    r_status = write_modis_data_variable(i_out_filename,$
                                       r_bias_sst_as_int,$
                                       i_dataset_name,$
                                       i_long_name,$
                                       i_units,$
                                       r_slope_bias_error,r_intercept_bias_error,$
                                       r_fill_value,r_data_type,$
                                       i_valid_min,i_valid_max,i_coordinates,i_source,i_comment);
endif else begin
    ; If we are processing from original NetCDF file, use the different scaling to convert from short to byte and also reset the scale factor and offset.
    scaling_status = apply_scaling_from_short_to_byte($
                         r_slope_bias_error,$
                         r_bias_sst,$
                         o_byte_variable_array,$
                         o_byte_scale_factor,$
                         o_byte_add_offset);
if (debug_mode) then begin
print, 'Content of original short variable from NetCDF file:'
print, '          r_slope_bias_error          = ', r_slope_bias_error;
print, '          r_intercept_bias_error      = ', r_intercept_bias_error;   
print, 'ORIGINAL  : r_bias_sst[0,0]           = ', r_bias_sst[0,0];
print, 'CALCULATED: r_bias_sst[0,0]*r_slope_bias_error + r_intercept_bias_error = ', r_bias_sst[0,0] * r_slope_bias_error + r_intercept_bias_error;   
print, ''
print, 'Content of scaled byte variable to be written to NetCDF file:'
print, '          o_byte_scale_factor              = ', o_byte_scale_factor;
print, '          o_byte_add_offset                = ', o_byte_add_offset;   
print, 'ORIGINAL  o_byte_variable_array[0,0]) = ', o_byte_variable_array[0,0]
print, 'CALCULATED:o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset     = ', o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset;
endif

r_status = write_modis_data_variable(i_out_filename,$
                                   o_byte_variable_array,$
                                   i_dataset_name,$
                                   i_long_name,$
                                   i_units,$
                                   o_byte_scale_factor,o_byte_add_offset,$
                                   r_fill_value,r_data_type,$
                                   i_valid_min,i_valid_max,i_coordinates,i_source,i_comment);
endelse


if (TEST_PARAMETER EQ "BAD_BIAS_ERROR_VARIABLE_WRITE") then begin
     r_status = FAILURE;
endif
if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot write variable ' + i_dataset_name + ' to file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

endif

if ((SIZE(r_stdv_sst,/N_ELEMENTS)) GT 0) then begin

i_dataset_name = 'SSES_standard_deviation_error';
if (strcmp(i_convert_to_kelvin,'yes')) then begin
    i_units = 'kelvin';
end else begin
    i_units = 'celsius';
end
r_fill_value = BYTE_FILL_VALUE;
i_valid_min = -127B;
i_valid_max = SIGNED_BYTE_VALID_MAX; place holder
i_coordinates = 'lon lat';
i_long_name =  'SSES standard deviation error based on proximity confidence flags';
i_source = ''; 
i_comment = "thermal IR SST standard deviation error; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";

r_stdv_sst_as_int = INTARR(num_columns,num_rows,/NOZERO);

; If we are not processing from original NetCDF file, use the "converted" intercept value. 
if (GETENV('GHRSST_MODIS_L2P_CONVERTING_FROM_ORIGINAL_NETCDF_FILES') NE 'true') then begin
    l_status = convert_to_signed_byte(r_stdv_sst,r_intercept_standard_deviation_sst,r_stdv_sst_as_int);
    ; Write the integer array.  NetCDF should do the conversion from integer to byte on your behalf.
    r_status = write_modis_data_variable(i_out_filename,$
                                       r_stdv_sst_as_int,$
                                       i_dataset_name,$
                                       i_long_name,$
                                       i_units,$
                                       r_slope_standard_deviation_sst,r_intercept_standard_deviation_sst,$
                                       r_fill_value,r_data_type,$
                                       i_valid_min,i_valid_max,i_coordinates,i_source,i_comment);
endif else begin
    ; If we are processing from original NetCDF file, use the different scaling to convert from short to byte and also reset the scale factor and offset.
    scaling_status = apply_scaling_from_short_to_byte_for_stdv_variable($
                         r_slope_standard_deviation_sst,$
                         r_stdv_sst,$
                         o_byte_variable_array,$
                         o_byte_scale_factor,$
                         o_byte_add_offset);

if (debug_mode) then begin
print, 'Content of original short variable from NetCDF file:'
print, '          r_slope_standard_deviation_sst = ', r_slope_standard_deviation_sst;
print, '          r_intercept_standard_deviation_sst = ', r_intercept_standard_deviation_sst;
print, 'ORIGINAL  : r_stdv_sst[0,0]           = ', r_stdv_sst[0,0];
print, 'CALCULATED: r_stdv_sst[0,0]*r_slope_standard_deviation_sst + r_intercept_standard_deviation_sst = ', r_stdv_sst[0,0] * r_slope_standard_deviation_sst + r_intercept_standard_deviation_sst;
print, ''
print, 'Content of scaled byte variable to be written to NetCDF file:'
print, '          o_byte_scale_factor              = ', o_byte_scale_factor;
print, '          o_byte_add_offset                = ', o_byte_add_offset;
print, 'ORIGINAL  o_byte_variable_array[0,0]) = ', o_byte_variable_array[0,0]
print, 'CALCULATED:o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset     = ', o_byte_variable_array[0,0]*o_byte_scale_factor + o_byte_add_offset;
endif

r_status = write_modis_data_variable(i_out_filename,$
                                   o_byte_variable_array,$
                                   i_dataset_name,$
                                   i_long_name,$
                                   i_units,$
                                   o_byte_scale_factor,o_byte_add_offset,$
                                   r_fill_value,r_data_type,$
                                   i_valid_min,i_valid_max,i_coordinates,i_source,i_comment);
endelse




if (TEST_PARAMETER EQ "BAD_STANDARD_DEVIATION_ERROR_VARIABLE_WRITE") then begin
     r_status = FAILURE;
endif
if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot write variable ' + i_dataset_name + ' to file ' + i_out_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

endif

; END_BLOCK_4
endif

;--------------------------------------------------------------------------------
; Additional byte arrays for various flags.
;--------------------------------------------------------------------------------

; BEGIN_BLOCK_5
EXECUTE_THIS_BLOCK = 1; 

if (EXECUTE_THIS_BLOCK EQ 1) then begin

;
; Write the rejection_flag to NetCDF file.
;

rejection_flag = BYTARR(long_attributes_values[Pixels_per_Scan_Line_index],$
                        long_attributes_values[Number_of_Scan_Lines_index]);
; Above array is normally set to zero by IDL.

;
; Set all indices found in l_land_indices to 64B for Land.
; Flip the 6th bit by using the OR operator.
;

for rejection_index = 0L, (num_land_indices - 1) do begin
    rejection_flag[l_land_indices[rejection_index]] =  $
        rejection_flag[l_land_indices[rejection_index]] OR 1B;
endfor

i_dataset_name = 'rejection_flag';
i_units = 'none';
r_data_type = 'BYTE';
i_long_name = 'rejection_flag';
i_comment = "b0 : 1 = SST out of range, b1 : 1 = Cosmetic value, b2 : 1 = IR cloudy, b3 : 1 = MW rain, b4 : 1 = ice, b5 : 1 = MW wind, b6 : 1 = Land, b7 : 1 = spare";

r_status = write_barebone_modis_data_variable(i_out_filename,$
                                   rejection_flag,$
                                   i_dataset_name,$
                                   i_long_name,$
                                   i_units,$
                                   r_data_type,$
                                   i_coordinates,i_source,i_comment);

if (TEST_PARAMETER EQ "BAD_REJECTION_FLAG_VARIABLE_WRITE") then begin
     r_status = FAILURE;
endif
if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot write variable ' + i_dataset_name + ' to file ' + i_filename;
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

;
; Write the confidence_flag to NetCDF file.
;

confidence_flag = BYTARR(long_attributes_values[Pixels_per_Scan_Line_index],$
                        long_attributes_values[Number_of_Scan_Lines_index]);

confidence_flag[*] = 64B;   bit 6 is set for all values using the [*] indexer.

i_dataset_name = 'confidence_flag';
i_units = 'none';
r_data_type = 'BYTE';
i_long_name = 'confidence_flag';
i_comment = "b0 : 1 = potential side lobe contamination; b1 : 1 = relaxed rain contamination suspected; b2 : 1 = TMI SST retrieved in SST < 285K; b3 : 1 = high wind speed retrieval; b4 : 1 = sea ice retrieval for MW data; b5 : 1 = sun glint;  b6 : 1 = L2 native bias and standard deviation; b7 : 1 = L2 native confidence value";

r_status = write_barebone_modis_data_variable(i_out_filename,$
                                   confidence_flag,$
                                   i_dataset_name,$
                                   i_long_name,$
                                   i_units,$
                                   r_data_type,$
                                   i_coordinates,i_source,i_comment);


if (TEST_PARAMETER EQ "BAD_CONFIDENCE_FLAG_VARIABLE_WRITE") then begin
     r_status = FAILURE;
endif
if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot write variable ' + i_dataset_name + ' to file ' + i_filename; 
    print, debug_module + msg;
    donotcare = error_log_writer(routine_name,msg);
    FILE_DELETE, i_out_filename, /QUIET;
    ; Must return immediately.
    return, r_status
endif

endif
; END_BLOCK_5

;--------------------------------------------------------------------------------
; If this dataset is taken at night, convert additional variables
; For day dataset, convert additional variables as well.
;--------------------------------------------------------------------------------

; BEGIN_BLOCK_6
EXECUTE_THIS_BLOCK = 1; 

if (EXECUTE_THIS_BLOCK EQ 1) then begin

;print, 'convert_modis_from_hdf_to_netcdf: r_day_or_night = ', r_day_or_night; 

;if (r_day_or_night EQ 'Night' || r_day_or_night EQ 'Mixed') then begin
    l_status = convert_additional_night_hdf_variables(i_filename,i_out_filename,num_lons, $
                   num_lats,i_convert_to_kelvin, $
                   r_num_bad_scan_lines, $
                   r_scan_line_flag_array, $
                   i_test_parameter);
;    do_not_care = verify_returned_status(in_filename_only,l_status,SUCCESS,'Cannot read additional variables for Night or Mixed');
    ; Remove in-complete NetCDF file.
;    if (l_status NE SUCCESS) then begin
;        l_do_not_care = clean_up_modis_processing(i_out_filename);
;        r_status = FAILURE;
;    endif
;    print, 'convert_modis_from_hdf_to_netcdf: Night or Mixed'; 
;endif else begin
;    if (r_day_or_night EQ 'Day') then begin
        l_status = convert_additional_day_hdf_variables(i_filename,i_out_filename,$
                r_num_bad_scan_lines, $
                r_scan_line_flag_array, $
                i_test_parameter);
;        do_not_care = verify_returned_status(in_filename_only,l_status,SUCCESS,'Cannot read additional variables for Day');
        ; Remove in-complete NetCDF file.
;        if (l_status NE SUCCESS) then begin
;            l_do_not_care = clean_up_modis_processing(i_out_filename);
;            r_status = FAILURE;
;        endif

;        print, 'convert_modis_from_hdf_to_netcdf: r_day_or_night = Day'; 

;    endif
;endelse

endif
; END_BLOCK_6


;
; If the data type is Refined, append the ancillary data from the Filled Quicklook
; to the MODIS L2P.
;

if (i_processing_type EQ "REFINED") then begin
    
;    l_uncompress_status = uncompress_one_modis_dataset($
;                          i_data_filename,$
;                          i_processing_type,$
;                          i_out_filename);

    ; Extract the directory from the input data file name.
    scratch_directory = FILE_DIRNAME(i_filename);

    ; Extract the name only from the refined MODIS L2P
    filled_quick_name_only = FILE_BASENAME(i_out_filename); 

    ; Build the Filled Quicklook MODIS L2P filename.
    ; Assumption: the file has been uncompressed from BZ2 to .nc

    filled_quicklook_filename = scratch_directory + "/" + filled_quick_name_only;

    ; If the file has been previously uncompressd by the Perl code,
    ; we will append the ancillary data to the Refined MODIS L2P.

    if (FILE_TEST(filled_quicklook_filename) EQ 1) then begin

        ; Build the list of variable names to loop through.
        ancillary_variable_names_array = ["aerosol_optical_depth",   $
                                          "DT_analysis",             $
                                          "sea_ice_fraction",        $
                                          "surface_solar_irradiance",$
                                          "wind_speed"];

        ; For each variable, attempt to append it to the Refined MODIS L2P.

        for variable_name_index = 0, (size(ancillary_variable_names_array,/N_ELEMENTS) - 1) do begin
          l_status = append_ancillary_data_variable(filled_quicklook_filename,$
                       ancillary_variable_names_array[variable_name_index],$
                       i_out_filename,$
                       r_day_or_night,$
                       r_start_node,$
                       r_end_node);
        endfor

        ; Delete the staged Filled Quicklook file.
        FILE_DELETE, filled_quicklook_filename, /QUIET;
    endif
endif

; ---------- Close up shop ---------- 

return, r_status
end
