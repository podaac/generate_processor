;  Copyright 2015, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id$
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

FUNCTION identify_bad_scan_lines_fast, $
             i_geolocation_array, $
             i_array_name, $
             r_good_scan_lines_array, $
             r_num_good_scan_lines, $
             r_bad_scan_lines_array, $
             r_num_bad_scan_lines, $
             r_bad_fill_value, $
             r_scan_line_flag_array

; Function identify the bad scan lines containing values out of the [-180.0,180.0] range for
; longitude and [-90.0,90.0] for latitudes.
;
; Assumptions:
;
;   1. TBD.
;

;------------------------------------------------------------------------------------------------

; Load constants.

@modis_data_config.cfg

; Define local variables.

r_status = SUCCESS;

routine_name = "identify_bad_scan_lines_fast";

; Get the DEBUG_MODE if it is set.

debug_module = 'identify_bad_scan_lines_fast:';
debug_mode = 0
if (STRUPCASE(GETENV('GHRSST_MODIS_L2P_DEBUG_MODE')) EQ 'TRUE') then begin
    debug_mode = 1;
endif

VALID_LON_MIN = -181.0;    Bryan Franz suggested we keep it safe by using -181.0 so we wouldn't
VALID_LON_MAX =  181.0;    toss out a -180.000001
VALID_LAT_MIN = -91.0;     Same goes for the latitude.
VALID_LAT_MAX =  91.0;

; We set the min_value according to the name of the array whether it is
; latitude or longitude.
;

if (i_array_name EQ 'latitude') then begin
    min_valid_value = VALID_LAT_MIN; 
    max_valid_value = VALID_LAT_MAX; 
    r_bad_fill_value = LAT_FILL_VALUE; 
endif else begin
    if (i_array_name EQ 'longitude') then begin
        min_valid_value = VALID_LON_MIN; 
        max_valid_value = VALID_LON_MAX; 
        r_bad_fill_value = LON_FILL_VALUE; 
    endif else begin
        print, 'identify_bad_scan_lines_fast: ERROR, Unrecognize array name: ', i_array_name;
        print, 'identify_bad_scan_lines_fast: Valid values are latitude and longitude';
        r_status = FAILURE;
        ; Must return immediately.
        return, r_status
    end
endelse

; Get the size of the incoming array.

size_array = size(i_geolocation_array);

; Extract individual dimensions.
;
; Indices      Value
;   0          number of dimensions
;   1          columns
;   2          rows
;   3          data type
;   4          number of elements

if (size_array[0] ne 2) then begin
    print, 'convert_modis_from_hdf_to_netcdf: ERROR, Incoming array must be of two dimensions';
    r_status = FAILURE;
    ; Must return immediately.
    return, r_status
endif

num_columns = size_array[1]; 
num_rows    = size_array[2]; 

;help, num_columns;
;help, num_rows;

; Allocate the return array.  We will need at most num_rows

r_good_scan_lines_array = LONARR(num_rows);
r_num_good_scan_lines     = 0L;
r_bad_scan_lines_array = LONARR(num_rows);
r_num_bad_scan_lines     = 0L;
r_scan_line_flag_array   = LONARR(num_rows);

;help, r_bad_scan_lines_array;

;
; For each row, if one value among the column is out of range, we mark the row as
; bad.  Save the index of the row in the r_bad_scan_lines_array.
;
; a = [[0,0,0],[2,3,3]]
;
; print, a
;       0       0       0
;       2       3       3
; help, a
;       A               INT       = Array[3, 2]
;
; The columns is 3, the rows is 2.
;

bad_scan_lines_index  = 0L; 
good_scan_lines_index = 0L; 

l_fill_value_saved = 0;
;help, i_geolocation_array;
 
for row_index = 0L, (num_rows - 1) do begin

    ; Look through all columns.  If we find a bad value, mark the index of the row and bail.
    found_bad_value = 0;
    column_index = 0L;

    one_dim_array = i_geolocation_array[*,row_index];

    ; Look for values smaller than minimal.

    r_bad_scan_lines_array = WHERE((one_dim_array LT min_valid_value), r_num_bad_scan_lines);

    ; If did not find any values smaller than minimal, look for values larger than maximium.
   
    if (r_num_bad_scan_lines EQ 0) then begin
        r_bad_scan_lines_array = WHERE((one_dim_array GT max_valid_value), r_num_bad_scan_lines);
    endif

    ; Some of the values can also be NaN, we have a look.  If we find at least one NaN, break out of the for loop.

    for column_index = 0L, (num_columns -1) do begin
        if (FINITE(i_geolocation_array[column_index,row_index],/NAN)) then begin
            r_num_bad_scan_lines = 1;
            break;
        endif
    endfor

    ; If we went through all the columns and did not find a bad value, then the row is a good scan

    if (r_num_bad_scan_lines GT 0) then begin
        r_scan_line_flag_array[row_index] = 0;  Which means this scan is bad.
    endif else begin
        r_scan_line_flag_array[row_index] = 1;  Which means this scan is good.
    endelse

endfor

; Count the number of good and bad scanlines and also save the indices where the value is either 1 or 0.

r_good_scan_lines_array = WHERE(r_scan_line_flag_array EQ 1,r_num_good_scan_lines);
r_bad_scan_lines_array  = WHERE(r_scan_line_flag_array EQ 0,r_num_bad_scan_lines);

; ---------- Close up shop ---------- 

return, r_status
end
