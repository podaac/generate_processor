#!/usr/local/bin/perl

#  Copyright 2007, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id: stage_modis_datasets_for_processing.pl,v 1.4 2007/11/13 16:41:39 qchau Exp $
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM
# New Request #xxxx

#
#
# Subroutine stage the MODIS datasets for processing by copying the compressed file to the
# staging area.
#
# Assumption:
#
#   1) The file to be staged exist.
#   2) TBD. 
#
#------------------------------------------------------------------------------------------------

do "$GHRSST_PERL_LIB_DIRECTORY/iterate_stage_commands.pl";

sub stage_modis_datasets_for_processing {

    # Returned status.  Value of 0 means ok, 1 means bad.

    my $o_status = 0;

    #
    # Get input.
    #

    my $ref_uncompressed_data_filelist = shift; 
    my $i_scratch_area                 = shift;
    my $i_processing_type              = shift;  # Either QUICKLOOK or REFINED
    my $i_datasource                   = shift;  # Instrument name MODIS_A or MODIS_T
    my $i_uncompress_flag              = shift;  # Perform bunzip2 or not: {yes,no}
    my $ref_l2p_core_name_only_filelist = shift;

    # 
    # Local variables.  The @$ on the Right Hand Side (RHS) dereference the reference.
    #

    my @l_uncompressed_data_filelist = @$ref_uncompressed_data_filelist;
    my @l_l2p_core_name_only_filelist = @$ref_l2p_core_name_only_filelist;
    my $num_uncompressed_data_files = @l_uncompressed_data_filelist;

    # For every file in the list, perform the copying to the stage area.

print "\n";
print ">>> stage_modis_datasets_for_processing: num_uncompressed_data_files = $num_uncompressed_data_files\n";

    my $num_datasets_staged_success = 0;
    my $num_datasets_staged_failed  = 0;

    for ($count = 0; $count < $num_uncompressed_data_files; $count++) {
        # Attempt the stage commands as many times as necessary.
        my $stage_status = iterate_stage_commands(
                               $i_scratch_area,
                               $i_processing_type,
                               $i_uncompress_flag,
                               $l_uncompressed_data_filelist[$count],
                               $l_l2p_core_name_only_filelist[$count]);

        # A status of 0 means good.
        if ($stage_status == 0) {
            $num_datasets_staged_success = $num_datasets_staged_success + 1;
        } else {
            $num_datasets_staged_failed  = $num_datasets_staged_failed  + 1;
        }

    } # endfor ($count = 0; $count < $num_uncompressed_data_files; $count++)

    #
    # Report status of staging.
    #
    print "stage_modis_datasets_for_processing: num_datasets_staged_success = $num_datasets_staged_success\n";
    print "stage_modis_datasets_for_processing: num_datasets_staged_failed  = $num_datasets_staged_failed\n";

    # ---------- Close up shop ----------
    return ($o_status);

} # end sub stage_modis_datasets_for_processing
